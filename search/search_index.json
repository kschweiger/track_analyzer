{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"geo-track-analyzer","text":"<p>Geo-Track-Analyzer aims to define a common interface for analyzing and visualizing geospacial data tracks from various sources.</p> Package Meta CI"},{"location":"api_comparison/","title":"Comparison Reference","text":""},{"location":"api_comparison/#geo_track_analyzer.compare.check_segment_bound_overlap","title":"<code>check_segment_bound_overlap(reference_segments, segments)</code>","text":"<p>Check if segments are within the bounds of a reference segment</p> <p>Parameters:</p> Name Type Description Default <code>reference_segments</code> <code>GPXTrackSegment</code> <p>Segment defining the bounds inside which the other segments should be contained</p> required <code>segments</code> <code>list[GPXTrackSegment]</code> <p>Segments to be checked</p> required <p>Returns:</p> Type Description <code>list[bool]</code> <p>List of bools specifying if the segments are inside the refence bounds</p> Source code in <code>geo_track_analyzer/compare.py</code> <pre><code>def check_segment_bound_overlap(\n    reference_segments: GPXTrackSegment, segments: list[GPXTrackSegment]\n) -&gt; list[bool]:\n    \"\"\"Check if segments are within the bounds of a reference segment\n\n    :param reference_segments: Segment defining the bounds inside which the other\n        segments should be contained\n    :param segments: Segments to be checked\n\n    :return: List of bools specifying if the segments are inside the refence bounds\n    \"\"\"\n    reference_bounds = reference_segments.get_bounds()\n\n    check_bounds(reference_bounds)\n\n    res = []\n\n    for segment in segments:\n        bounds = segment.get_bounds()\n\n        check_bounds(bounds)\n\n        res.append(\n            bounds.min_latitude &lt; reference_bounds.max_latitude  # type: ignore\n            and bounds.min_longitude &lt; reference_bounds.max_latitude  # type: ignore\n            and bounds.max_latitude &gt; reference_bounds.min_latitude  # type: ignore\n            and bounds.max_longitude &gt; reference_bounds.min_longitude  # type: ignore\n        )\n\n    return res\n</code></pre>"},{"location":"api_comparison/#geo_track_analyzer.compare.get_segment_overlap","title":"<code>get_segment_overlap(base_segment, match_segment, grid_width, max_queue_normalize=5, allow_points_outside_bounds=5, overlap_threshold=0.75)</code>","text":"<p>Compare the tracks of two segements and caclulate the overlap.</p> <p>Parameters:</p> Name Type Description Default <code>base_segment</code> <code>GPXTrackSegment</code> <p>Base segement in which the match segment should be found</p> required <code>match_segment</code> <code>GPXTrackSegment</code> <p>Other segmeent that should be found in the base segement</p> required <code>grid_width</code> <code>float</code> <p>Width (in meters) of the grid that will be filled to estimate the overalp.</p> required <code>max_queue_normalize</code> <code>int</code> <p>Minimum number of successive points in the segment between two points falling into same plate bin.</p> <code>5</code> <code>allow_points_outside_bounds</code> <code>int</code> <p>Number of points between sub segments allowed for merging the segments.</p> <code>5</code> <code>overlap_threshold</code> <code>float</code> <p>Minimum overlap required to return the overlap data.</p> <code>0.75</code> <p>Returns:</p> Type Description <code>list[SegmentOverlap]</code> <p>list of SegmentOverlap objects.</p> Source code in <code>geo_track_analyzer/compare.py</code> <pre><code>def get_segment_overlap(\n    base_segment: GPXTrackSegment,\n    match_segment: GPXTrackSegment,\n    grid_width: float,\n    max_queue_normalize: int = 5,\n    allow_points_outside_bounds: int = 5,\n    overlap_threshold: float = 0.75,\n) -&gt; list[SegmentOverlap]:\n    \"\"\"Compare the tracks of two segements and caclulate the overlap.\n\n    :param base_segment: Base segement in which the match segment should be found\n    :param match_segment: Other segmeent that should be found in the base segement\n    :param grid_width: Width (in meters) of the grid that will be filled to estimate\n                       the overalp.\n    :param max_queue_normalize: Minimum number of successive points in the segment\n                                between two points falling into same plate bin.\n    :param allow_points_outside_bounds: Number of points between sub segments allowed\n                                        for merging the segments.\n    :param overlap_threshold: Minimum overlap required to return the overlap data.\n\n    :return: list of SegmentOverlap objects.\n    \"\"\"\n    bounds_match = match_segment.get_bounds()\n\n    check_bounds(bounds_match)\n\n    cropped_base_segment = crop_segment_to_bounds(\n        base_segment,\n        bounds_match.min_latitude,  # type: ignore\n        bounds_match.min_longitude,  # type: ignore\n        bounds_match.max_latitude,  # type: ignore\n        bounds_match.max_longitude,  # type: ignore\n    )\n\n    plate_base = convert_segment_to_plate(\n        cropped_base_segment,\n        grid_width,\n        bounds_match.min_latitude,  # type: ignore\n        bounds_match.min_longitude,  # type: ignore\n        bounds_match.max_latitude,  # type: ignore\n        bounds_match.max_longitude,  # type: ignore\n        True,\n        max_queue_normalize,\n    )\n\n    plate_match = convert_segment_to_plate(\n        match_segment,\n        grid_width,\n        bounds_match.min_latitude,  # type: ignore\n        bounds_match.min_longitude,  # type: ignore\n        bounds_match.max_latitude,  # type: ignore\n        bounds_match.max_longitude,  # type: ignore\n        True,\n        max_queue_normalize,\n    )\n\n    # Check if the match segment appears muzltiple times in the base segemnt\n    if plate_base.max() &gt; 1:\n        logger.debug(\n            \"Multiple occurances of points within match bounds in base segment\"\n        )\n        base_points_in_bounds = get_points_inside_bounds(\n            base_segment,\n            bounds_match.min_latitude,  # type: ignore\n            bounds_match.min_longitude,  # type: ignore\n            bounds_match.max_latitude,  # type: ignore\n            bounds_match.max_longitude,  # type: ignore\n        )\n\n        id_ranges_in_bounds = _extract_ranges(\n            base_points_in_bounds, allow_points_outside_bounds\n        )\n\n        sub_segments = split_segment_by_id(base_segment, id_ranges_in_bounds)\n        sub_segment_overlaps = []\n        for i_sub_segment, (sub_segment, id_sub_segment) in enumerate(\n            zip(sub_segments, id_ranges_in_bounds)\n        ):\n            logger.debug(\n                \"Processing overlap in sub-plate %s/%s\",\n                i_sub_segment + 1,\n                len(sub_segments),\n            )\n            sub_plate = convert_segment_to_plate(\n                sub_segment,\n                grid_width,\n                bounds_match.min_latitude,  # type: ignore\n                bounds_match.min_longitude,  # type: ignore\n                bounds_match.max_latitude,  # type: ignore\n                bounds_match.max_longitude,  # type: ignore\n                True,\n                max_queue_normalize,\n            )\n            sub_segment_overlap = _calc_plate_overlap(\n                base_segment=sub_segment,\n                plate_base=sub_plate,\n                match_segment=match_segment,\n                plate_match=plate_match,\n            )\n\n            subseg_start, _ = id_sub_segment\n            sub_segment_overlap.start_idx += subseg_start\n            sub_segment_overlap.end_idx += subseg_start\n\n            if sub_segment_overlap.overlap &gt;= overlap_threshold:\n                sub_segment_overlaps.append(sub_segment_overlap)\n\n        return sorted(sub_segment_overlaps, key=lambda x: x.overlap, reverse=True)\n    else:\n        logger.debug(\"Processing overlap in plate\")\n        segment_overlap = _calc_plate_overlap(\n            base_segment=base_segment,\n            plate_base=plate_base,\n            match_segment=match_segment,\n            plate_match=plate_match,\n        )\n        if segment_overlap.overlap &gt;= overlap_threshold:\n            return [segment_overlap]\n        else:\n            return []\n</code></pre>"},{"location":"api_comparison/#geo_track_analyzer.compare.convert_segment_to_plate","title":"<code>convert_segment_to_plate(segment, gird_width, bounds_min_latitude, bounds_min_longitude, bounds_max_latitude, bounds_max_longitude, normalize=False, max_queue_normalize=5)</code>","text":"<p>Takes a GPXSegement and fills bins of a 2D array (called plate) with the passed bin width. Bins will start at the min latitude and longited values.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>GPXTrackSegment</code> <p>The GPXPoints of the Segment will be filled into the plate</p> required <code>gird_width</code> <code>float</code> <p>Width (in meters) of the grid</p> required <code>bounds_min_latitude</code> <code>float</code> <p>Minimum latitude of the grid</p> required <code>bounds_min_longitude</code> <code>float</code> <p>Minimum longitude of the grid</p> required <code>bounds_max_latitude</code> <code>float</code> <p>Maximum latitude of the gtid. Bins may end with larger values than passed here dependeing on the grid width</p> required <code>bounds_max_longitude</code> <code>float</code> <p>Maximum longitude of the grid. Bins may end with larger values than passed here dependeing on the grid width</p> required <code>normalize</code> <code>bool</code> <p>If True, successive points (defined by the max_queue_normalize) will not change the values in a bin. This means that each bin values should have the value 1 except there is overlap with points later in the track. To decide this the previous max_queue_normalize points will be considered. So this value dependes on the chosen gridwidth.</p> <code>False</code> <code>max_queue_normalize</code> <code>int</code> <p>Number of previous bins considered when normalize is set to true.</p> <code>5</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>2DArray representing the plate.</p> Source code in <code>geo_track_analyzer/compare.py</code> <pre><code>def convert_segment_to_plate(\n    segment: GPXTrackSegment,\n    gird_width: float,\n    bounds_min_latitude: float,\n    bounds_min_longitude: float,\n    bounds_max_latitude: float,\n    bounds_max_longitude: float,\n    normalize: bool = False,\n    max_queue_normalize: int = 5,\n) -&gt; np.ndarray:\n    \"\"\"\n    Takes a GPXSegement and fills bins of a 2D array (called plate) with the passed\n    bin width. Bins will start at the min latitude and longited values.\n\n    :param segment: The GPXPoints of the Segment will be filled into the plate\n    :param gird_width: Width (in meters) of the grid\n    :param bounds_min_latitude: Minimum latitude of the grid\n    :param bounds_min_longitude: Minimum longitude of the grid\n    :param bounds_max_latitude: Maximum latitude of the gtid. Bins may end with larger\n                                values than passed here dependeing on the grid width\n    :param bounds_max_longitude: Maximum longitude of the grid. Bins may end with larger\n                                values than passed here dependeing on the grid width\n    :param normalize: If True, successive points (defined by the max_queue_normalize)\n                      will not change the values in a bin. This means that each bin\n                      values should have the value 1 except there is overlap with\n                      points later in the track. To decide this the previous\n                      max_queue_normalize points will be considered. So this value\n                      dependes on the chosen gridwidth.\n    :param max_queue_normalize: Number of previous bins considered when normalize is\n                                set to true.\n\n    :return: 2DArray representing the plate.\n    \"\"\"\n    bins_latitude, bins_longitude = derive_plate_bins(\n        gird_width,\n        bounds_min_latitude,\n        bounds_min_longitude,\n        bounds_max_latitude,\n        bounds_max_longitude,\n    )\n\n    _lat_bins = np.array([b[0] for b in bins_latitude])\n    _long_bins = np.array([b[1] for b in bins_longitude])\n\n    lats, longs = [], []\n    for point in segment.points:\n        lats.append(point.latitude)\n        longs.append(point.longitude)\n\n    # np.digitize starts with 1. We want 0 as first bin\n    segment_lat_bins = np.digitize(lats, _lat_bins) - 1\n    segment_long_bins = np.digitize(longs, _long_bins) - 1\n\n    plate = np.zeros(shape=(len(bins_latitude), len(bins_longitude)))\n\n    prev_bins = deque(maxlen=max_queue_normalize)  # type: ignore\n\n    for lat, long in zip(segment_lat_bins, segment_long_bins):\n        if normalize:\n            if any((lat, long) == prev_bin for prev_bin in prev_bins):\n                continue\n            prev_bins.append((lat, long))\n            plate[lat, long] += 1\n        else:\n            plate[lat, long] += 1\n\n    return np.flip(plate, axis=0)\n</code></pre>"},{"location":"api_enhancer/","title":"Enhancer Reference","text":""},{"location":"api_enhancer/#geo_track_analyzer.OpenTopoElevationEnhancer","title":"<code>OpenTopoElevationEnhancer(url='https://api.opentopodata.org/', dataset='eudem25m', interpolation='cubic', skip_checks=False)</code>","text":"<p>             Bases: <code>ElevationEnhancer</code></p> <p>Use the/a OpenTopoData API (https://opentopodata.org) to enhance a GPX track with elevation information.</p> <p>Setup the enhancer via a opentopodata rest api.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>REST api entrypoint url, defaults to \"https://api.opentopodata.org/\"</p> <code>'https://api.opentopodata.org/'</code> <code>dataset</code> <code>str</code> <p>Dataset of elevation data , defaults to \"eudem25m\"</p> <code>'eudem25m'</code> <code>interpolation</code> <code>str</code> <p>Interpolation method, defaults to \"cubic\"</p> <code>'cubic'</code> <code>skip_checks</code> <code>bool</code> <p>If true, health checks will be skipped on initialization, defaults to False</p> <code>False</code> <p>Raises:</p> Type Description <code>APIHealthCheckFailedError</code> <p>If connection can not established</p> <code>APIHealthCheckFailedError</code> <p>Any other error on health check</p> <code>APIDataNotAvailableError</code> <p>Dataset is not available at the endpoint</p> Source code in <code>geo_track_analyzer/enhancer.py</code> <pre><code>def __init__(\n    self,\n    url: str = \"https://api.opentopodata.org/\",\n    dataset: str = \"eudem25m\",\n    interpolation: str = \"cubic\",\n    skip_checks: bool = False,\n) -&gt; None:\n    \"\"\"\n    Setup the enhancer via a opentopodata rest api.\n\n    :param url: REST api entrypoint url, defaults to \"https://api.opentopodata.org/\"\n    :param dataset: Dataset of elevation data , defaults to \"eudem25m\"\n    :param interpolation: Interpolation method, defaults to \"cubic\"\n    :param skip_checks: If true, health checks will be skipped on initialization,\n        defaults to False\n    :raises APIHealthCheckFailedError: If connection can not established\n    :raises APIHealthCheckFailedError: Any other error on health check\n    :raises APIDataNotAvailableError: Dataset is not available at the endpoint\n    \"\"\"\n    self.base_url = url\n    self.url = f\"{url}/v1/{dataset}\"\n    self.interpolation = interpolation\n\n    if not skip_checks:\n        logger.debug(\"Doing server health check\")\n        try:\n            resp = requests.get(f\"{self.base_url}/health\")\n        except requests.exceptions.ConnectionError as e:\n            raise APIHealthCheckFailedError(str(e))\n        if resp.status_code != 200:\n            raise APIHealthCheckFailedError(resp.text)\n\n        logger.debug(\"Doing dataset check\")\n        resp = requests.get(f\"{self.base_url}/datasets\")\n        if resp.status_code != 200:\n            raise APIHealthCheckFailedError(resp.text)\n        datasets = [ds[\"name\"] for ds in resp.json()[\"results\"]]\n        if dataset not in datasets:\n            raise APIDataNotAvailableError(\"Dataset %s not available\" % dataset)\n</code></pre>"},{"location":"api_enhancer/#geo_track_analyzer.OpenTopoElevationEnhancer.enhance_track","title":"<code>enhance_track(track, inplace=False)</code>","text":"<p>Main method to enhance a passed GPX track with elevation information</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>GPXTrack</code> <p>Track to be enhanced.</p> required <p>Returns:</p> Type Description <code>GPXTrack</code> <p>The enhanced track</p> Source code in <code>geo_track_analyzer/enhancer.py</code> <pre><code>def enhance_track(self, track: GPXTrack, inplace: bool = False) -&gt; GPXTrack:\n    \"\"\"\n    Main method to enhance a passed GPX track with elevation information\n\n    :param track: Track to be enhanced.\n\n    :returns: The enhanced track\n    \"\"\"\n    if inplace:\n        track_ = track\n    else:\n        track_ = track.clone()\n\n    for segment in track_.segments:\n        request_coordinates = []\n        for point in segment.points:\n            request_coordinates.append((point.latitude, point.longitude))\n\n        elevations = self.get_elevation_data(request_coordinates)\n        for point, elevation in zip(segment.points, elevations):\n            point.elevation = elevation\n\n    return track_\n</code></pre>"},{"location":"api_enhancer/#geo_track_analyzer.OpenTopoElevationEnhancer.get_elevation_data","title":"<code>get_elevation_data(input_coordinates, split_requests=None)</code>","text":"<p>Send a post request to the api endoint to query elevation data for the passed input coordinates</p> <p>Parameters:</p> Name Type Description Default <code>input_coordinates</code> <code>list[tuple[float, float]]</code> <p>list of latitude, longitude tuples for which the elevation should be determined.</p> required <code>split_requests</code> <code>None | int</code> <p>Optionally split request into multiple requires to get around size restrictions, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>A list of Elevations for the passed coordinates.</p> <p>Raises:</p> Type Description <code>APIResponseError</code> <p>Any none 200 response form the endpoint</p> Source code in <code>geo_track_analyzer/enhancer.py</code> <pre><code>def get_elevation_data(\n    self,\n    input_coordinates: list[tuple[float, float]],\n    split_requests: None | int = None,\n) -&gt; list[float]:\n    \"\"\"Send a post request to the api endoint to query elevation data\n    for the passed input coordinates\n\n    :param input_coordinates: list of latitude, longitude tuples for which the\n        elevation should be determined.\n\n    :param split_requests: Optionally split request into multiple requires to get\n        around size restrictions, defaults to None\n    :raises APIResponseError: Any none 200 response form the endpoint\n\n    :returns: A list of Elevations for the passed coordinates.\n    \"\"\"\n    logger.debug(\"Getting elevation data\")\n    if split_requests is None:\n        split_input_coord = [input_coordinates]\n    else:\n        split_input_coord = [\n            input_coordinates[i : i + split_requests]\n            for i in range(0, len(input_coordinates), split_requests)\n        ]\n\n    ret_elevations = []\n    for coords in split_input_coord:\n        locations = \"\"\n        for latitude, longitude in coords:\n            locations += f\"{latitude},{longitude}|\"\n\n        locations = locations[:-1]\n        resp = requests.post(\n            self.url,\n            data={\n                \"locations\": locations,\n                \"interpolation\": self.interpolation,\n            },\n        )\n\n        if resp.status_code == 200:\n            result_data = resp.json()\n            for res in result_data[\"results\"]:\n                ret_elevations.append(res[\"elevation\"])\n\n        else:\n            raise APIResponseError(resp.text)\n\n    return ret_elevations\n</code></pre>"},{"location":"api_enhancer/#geo_track_analyzer.OpenElevationEnhancer","title":"<code>OpenElevationEnhancer(url='https://api.open-elevation.com')</code>","text":"<p>             Bases: <code>ElevationEnhancer</code></p> <p>Use the/a OpenElevation API (https://open-elevation.com) to enhance a GPX track with elevation information.</p> <p>Setup the enhancer via the url of the rest api of open-elevation</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the API gateway</p> <code>'https://api.open-elevation.com'</code> Source code in <code>geo_track_analyzer/enhancer.py</code> <pre><code>def __init__(self, url: str = \"https://api.open-elevation.com\") -&gt; None:\n    \"\"\"\n    Setup the enhancer via the url of the rest api of open-elevation\n\n    :param url: URL of the API gateway\n    \"\"\"\n    self.url = f\"{url}/api/v1/lookup\"\n\n    self.headers: Mapping[str, str] = CaseInsensitiveDict()\n    self.headers[\"Accept\"] = \"application/json\"\n    self.headers[\"Content-Type\"] = \"application/json\"\n</code></pre>"},{"location":"api_enhancer/#geo_track_analyzer.OpenElevationEnhancer.enhance_track","title":"<code>enhance_track(track, inplace=False)</code>","text":"<p>Main method to enhance a passed GPX track with elevation information</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>GPXTrack</code> <p>Track to be enhanced.</p> required <p>Returns:</p> Type Description <code>GPXTrack</code> <p>The enhanced track</p> Source code in <code>geo_track_analyzer/enhancer.py</code> <pre><code>def enhance_track(self, track: GPXTrack, inplace: bool = False) -&gt; GPXTrack:\n    \"\"\"\n    Main method to enhance a passed GPX track with elevation information\n\n    :param track: Track to be enhanced.\n\n    :returns: The enhanced track\n    \"\"\"\n    if inplace:\n        track_ = track\n    else:\n        track_ = track.clone()\n\n    for segment in track_.segments:\n        request_coordinates = []\n        for point in segment.points:\n            request_coordinates.append((point.latitude, point.longitude))\n\n        elevations = self.get_elevation_data(request_coordinates)\n        for point, elevation in zip(segment.points, elevations):\n            point.elevation = elevation\n\n    return track_\n</code></pre>"},{"location":"api_enhancer/#geo_track_analyzer.OpenElevationEnhancer.get_elevation_data","title":"<code>get_elevation_data(input_coordinates)</code>","text":"<p>Send a POST request to the Open-Elevation API specified in the init.</p> <p>Parameters:</p> Name Type Description Default <code>input_coordinates</code> <code>list[tuple[float, float]]</code> <p>list of latitude, longitude tuples for which the elevation should be determined.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>A list of Elevations for the passed coordinates.</p> Source code in <code>geo_track_analyzer/enhancer.py</code> <pre><code>def get_elevation_data(\n    self, input_coordinates: list[tuple[float, float]]\n) -&gt; list[float]:\n    \"\"\"\n    Send a POST request to the Open-Elevation API specified in the init.\n\n    :param input_coordinates: list of latitude, longitude tuples for which the\n        elevation should be determined.\n\n    :returns: A list of Elevations for the passed coordinates.\n    \"\"\"\n    data: Dict = {\"locations\": []}\n    for latitude, longitude in input_coordinates:\n        data[\"locations\"].append({\"latitude\": latitude, \"longitude\": longitude})\n\n    resp = requests.post(self.url, headers=self.headers, data=json.dumps(data))\n\n    if resp.status_code == 200:\n        result_data = resp.json()\n        ret_elevations = []\n        for res in result_data[\"results\"]:\n            ret_elevations.append(float(res[\"elevation\"]))\n\n        return ret_elevations\n    else:\n        raise APIResponseError(resp.text)\n</code></pre>"},{"location":"api_enhancer/#geo_track_analyzer.get_enhancer","title":"<code>get_enhancer(name)</code>","text":"<p>Get a Enhance object for a specific enpoint by passing a distinct name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>EnhancerType</code> <p>Name of enhancer. Chose OpenTopoElevation or OpenElevation</p> required <p>Returns:</p> Type Description <code>Type[Enhancer]</code> <p>An Enhancer object</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If an invalid name is passed</p> Source code in <code>geo_track_analyzer/enhancer.py</code> <pre><code>def get_enhancer(name: EnhancerType) -&gt; Type[Enhancer]:\n    \"\"\"Get a Enhance object for a specific enpoint by passing a distinct name\n\n    :param name: Name of enhancer. Chose OpenTopoElevation or OpenElevation\n    :raises NotImplementedError: If an invalid name is passed\n    :return: An Enhancer object\n    \"\"\"\n    if name == EnhancerType.OPENTOPOELEVATION:\n        return OpenTopoElevationEnhancer\n    elif name == EnhancerType.OPENELEVATION:\n        return OpenElevationEnhancer\n    else:\n        raise NotImplementedError(\"Can not return Enhancer for name %s\" % name)\n</code></pre>"},{"location":"api_model/","title":"Model Reference","text":""},{"location":"api_model/#geospacial-model-objects","title":"Geospacial model objects","text":""},{"location":"api_model/#geo_track_analyzer.model.Position2D","title":"<code>Position2D</code>","text":"<p>             Bases: <code>Model</code></p> <p>Position in a 2D latitude / longitude space</p>"},{"location":"api_model/#geo_track_analyzer.model.Position2D.latitude","title":"<code>latitude: float</code>  <code>instance-attribute</code>","text":"<p>Latitude of the point</p>"},{"location":"api_model/#geo_track_analyzer.model.Position2D.longitude","title":"<code>longitude: float</code>  <code>instance-attribute</code>","text":"<p>Longitude of the point</p>"},{"location":"api_model/#geo_track_analyzer.model.Position3D","title":"<code>Position3D</code>","text":"<p>             Bases: <code>Position2D</code></p> <p>Position in a 3D latitude / longitude / elevation space</p>"},{"location":"api_model/#geo_track_analyzer.model.Position3D.elevation","title":"<code>elevation: None | float</code>  <code>instance-attribute</code>","text":"<p>Elevation of the point</p>"},{"location":"api_model/#geo_track_analyzer.model.Position3D.latitude","title":"<code>latitude: float</code>  <code>instance-attribute</code>","text":"<p>Latitude of the point</p>"},{"location":"api_model/#geo_track_analyzer.model.Position3D.longitude","title":"<code>longitude: float</code>  <code>instance-attribute</code>","text":"<p>Longitude of the point</p>"},{"location":"api_model/#geo_track_analyzer.model.ElevationMetrics","title":"<code>ElevationMetrics</code>","text":"<p>             Bases: <code>Model</code></p> <p>Collection of elevation related metrics</p>"},{"location":"api_model/#geo_track_analyzer.model.ElevationMetrics.downhill","title":"<code>downhill: float</code>  <code>instance-attribute</code>","text":"<p>Downhill elevation in m</p>"},{"location":"api_model/#geo_track_analyzer.model.ElevationMetrics.slopes","title":"<code>slopes: list[float]</code>  <code>instance-attribute</code>","text":"<p>Slopes between points in a uphill/downhill section</p>"},{"location":"api_model/#geo_track_analyzer.model.ElevationMetrics.uphill","title":"<code>uphill: float</code>  <code>instance-attribute</code>","text":"<p>Upill elevation in m</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview","title":"<code>SegmentOverview</code>","text":"<p>             Bases: <code>Model</code></p> <p>Collection of metrics for a Segment</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.avg_velocity","title":"<code>avg_velocity: None | float</code>  <code>instance-attribute</code>","text":"<p>Average velocity in the segment in m/s (only considering velocities below the XX percentile)</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.avg_velocity_kmh","title":"<code>avg_velocity_kmh: None | float = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>avg_speed converted the km/h</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.downhill_elevation","title":"<code>downhill_elevation: None | float</code>  <code>instance-attribute</code>","text":"<p>Elevation traveled downhill in m</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.max_elevation","title":"<code>max_elevation: None | float</code>  <code>instance-attribute</code>","text":"<p>Maximum elevation in the segment in m</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.max_velocity","title":"<code>max_velocity: None | float</code>  <code>instance-attribute</code>","text":"<p>Maximum velocity in the segment in m/s (only considering velocities below the XX percentile)</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.max_velocity_kmh","title":"<code>max_velocity_kmh: None | float = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>max_velocity converted the km/h</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.min_elevation","title":"<code>min_elevation: None | float</code>  <code>instance-attribute</code>","text":"<p>Minimum elevation in the segment in m</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.moving_distance","title":"<code>moving_distance: float</code>  <code>instance-attribute</code>","text":"<p>Moving distance (point-to-point distance with velocity below a threshold) in m</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.moving_distance_km","title":"<code>moving_distance_km: float = Field(default=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>moving_distance converted the km</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.moving_time_seconds","title":"<code>moving_time_seconds: float</code>  <code>instance-attribute</code>","text":"<p>Moving time of a segment</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.total_distance","title":"<code>total_distance: float</code>  <code>instance-attribute</code>","text":"<p>Total distance of the segment in m</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.total_distance_km","title":"<code>total_distance_km: float = Field(default=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>total_distance converted the km</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.total_time_seconds","title":"<code>total_time_seconds: float</code>  <code>instance-attribute</code>","text":"<p>Total time of the segment</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverview.uphill_elevation","title":"<code>uphill_elevation: None | float</code>  <code>instance-attribute</code>","text":"<p>Elevation traveled uphill in m</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverlap","title":"<code>SegmentOverlap</code>","text":"<p>             Bases: <code>Model</code></p> <p>Represent the overlap between two segments</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverlap.end_idx","title":"<code>end_idx: int</code>  <code>instance-attribute</code>","text":"<p>Index of the last point in match segment</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverlap.end_point","title":"<code>end_point: Annotated[GPXTrackPoint, GPXTrackPointAfterValidator]</code>  <code>instance-attribute</code>","text":"<p>Last point matching the base segment</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverlap.inverse","title":"<code>inverse: bool</code>  <code>instance-attribute</code>","text":"<p>Match direction of the segment relative to the base</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverlap.overlap","title":"<code>overlap: float</code>  <code>instance-attribute</code>","text":"<p>Overlap ratio of the segments</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverlap.plate","title":"<code>plate: np_array_pydantic_annotated_typing(data_type=np.float32, dimensions=2)</code>  <code>instance-attribute</code>","text":"<p>2D representation of the segment overlap</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverlap.start_idx","title":"<code>start_idx: int</code>  <code>instance-attribute</code>","text":"<p>Index of the first point in match segment</p>"},{"location":"api_model/#geo_track_analyzer.model.SegmentOverlap.start_point","title":"<code>start_point: Annotated[GPXTrackPoint, GPXTrackPointAfterValidator]</code>  <code>instance-attribute</code>","text":"<p>First point matching the base segment</p>"},{"location":"api_model/#geo_track_analyzer.model.PointDistance","title":"<code>PointDistance</code>","text":"<p>             Bases: <code>Model</code></p> <p>Represents a distance calculati  on to a point in a GPX track.</p>"},{"location":"api_model/#geo_track_analyzer.model.PointDistance.distance","title":"<code>distance: float</code>  <code>instance-attribute</code>","text":"<p>The distance to the nearest point.</p>"},{"location":"api_model/#geo_track_analyzer.model.PointDistance.point","title":"<code>point: Annotated[GPXTrackPoint, GPXTrackPointAfterValidator]</code>  <code>instance-attribute</code>","text":"<p>The nearest point on the track.</p>"},{"location":"api_model/#geo_track_analyzer.model.PointDistance.point_idx_abs","title":"<code>point_idx_abs: int</code>  <code>instance-attribute</code>","text":"<p>The absolute index of the nearest point in the track.</p>"},{"location":"api_model/#geo_track_analyzer.model.PointDistance.segment_idx","title":"<code>segment_idx: int</code>  <code>instance-attribute</code>","text":"<p>The index of the segment containing the nearest point.</p>"},{"location":"api_model/#geo_track_analyzer.model.PointDistance.segment_point_idx","title":"<code>segment_point_idx: int</code>  <code>instance-attribute</code>","text":"<p>The index of the nearest point within the containing segment.</p>"},{"location":"api_model/#other-model-objects","title":"Other model objects","text":""},{"location":"api_model/#geo_track_analyzer.model.ZoneInterval","title":"<code>ZoneInterval</code>","text":"<p>             Bases: <code>Model</code></p> <p>Represents a zone interval. Start or end can be None implying and interval that include all value smaller or larger than the provided value, respectively</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If start and end are None</p>"},{"location":"api_model/#geo_track_analyzer.model.ZoneInterval.color","title":"<code>color: None | str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional color of the interval</p>"},{"location":"api_model/#geo_track_analyzer.model.ZoneInterval.end","title":"<code>end: None | PositiveInt</code>  <code>instance-attribute</code>","text":"<p>Upper bound of the interval</p>"},{"location":"api_model/#geo_track_analyzer.model.ZoneInterval.name","title":"<code>name: None | str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional name of the interval</p>"},{"location":"api_model/#geo_track_analyzer.model.ZoneInterval.start","title":"<code>start: None | PositiveInt</code>  <code>instance-attribute</code>","text":"<p>Lower bound of the interval</p>"},{"location":"api_model/#geo_track_analyzer.model.Zones","title":"<code>Zones</code>","text":"<p>             Bases: <code>Model</code></p> <p>Represents a collection of zones. The list of intervals is required to contain open ZoneIntervals in the fist and last position. Furthermore the intervals can not have gaps.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If not at least two intervals are provided in the object</p> <code>ValueError</code> <p>If some intervals have a name attached but not all (or none)</p> <code>ValueError</code> <p>If some intervals have a color attached but not all (or none)</p> <code>ValueError</code> <p>If first interval has a start value not equal to None</p> <code>ValueError</code> <p>If last interval has a end value not equal to None</p> <code>ValueError</code> <p>If consecutive intervals to not end/start with the same value</p>"},{"location":"api_model/#geo_track_analyzer.model.Zones.intervals","title":"<code>intervals: list[ZoneInterval]</code>  <code>instance-attribute</code>","text":"<p>A list of intervals comprising the collection of zones</p>"},{"location":"api_model/#geo_track_analyzer.model.Zones.meta_info","title":"<code>meta_info: None | str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional meta information about the zones</p>"},{"location":"api_tracks/","title":"Track Reference","text":""},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack","title":"<code>GPXFileTrack(gpx_file, n_track=0, stopped_speed_threshold=1, max_speed_percentile=95, heartrate_zones=None, power_zones=None, cadence_zones=None)</code>","text":"<p>             Bases: <code>Track</code></p> <p>Track that should be initialized by loading a .gpx file</p> <p>Initialize a Track object from a gpx file</p> <p>Parameters:</p> Name Type Description Default <code>gpx_file</code> <code>str</code> <p>Path to the gpx file.</p> required <code>n_track</code> <code>int</code> <p>Index of track in the gpx file, defaults to 0</p> <code>0</code> <code>stopped_speed_threshold</code> <code>float</code> <p>Minium speed required for a point to be count as moving, defaults to 1</p> <code>1</code> <code>max_speed_percentile</code> <code>int</code> <p>Points with speed outside of the percentile are not counted when analyzing the track, defaults to 95</p> <code>95</code> <code>heartrate_zones</code> <code>None | Zones</code> <p>Optional heartrate Zones, defaults to None</p> <code>None</code> <code>power_zones</code> <code>None | Zones</code> <p>Optional power Zones, defaults to None</p> <code>None</code> <code>cadence_zones</code> <code>None | Zones</code> <p>Optional cadence Zones, defaults to None</p> <code>None</code> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def __init__(\n    self,\n    gpx_file: str,\n    n_track: int = 0,\n    stopped_speed_threshold: float = 1,\n    max_speed_percentile: int = 95,\n    heartrate_zones: None | Zones = None,\n    power_zones: None | Zones = None,\n    cadence_zones: None | Zones = None,\n) -&gt; None:\n    \"\"\"Initialize a Track object from a gpx file\n\n    :param gpx_file: Path to the gpx file.\n    :param n_track: Index of track in the gpx file, defaults to 0\n    :param stopped_speed_threshold: Minium speed required for a point to be count\n        as moving, defaults to 1\n    :param max_speed_percentile: Points with speed outside of the percentile are not\n        counted when analyzing the track, defaults to 95\n    :param heartrate_zones: Optional heartrate Zones, defaults to None\n    :param power_zones: Optional power Zones, defaults to None\n    :param cadence_zones: Optional cadence Zones, defaults to None\n    \"\"\"\n\n    super().__init__(\n        stopped_speed_threshold=stopped_speed_threshold,\n        max_speed_percentile=max_speed_percentile,\n        heartrate_zones=heartrate_zones,\n        power_zones=power_zones,\n        cadence_zones=cadence_zones,\n    )\n\n    logger.info(\"Loading gpx track from file %s\", gpx_file)\n\n    gpx = self._get_gpx(gpx_file)\n\n    self._track = gpx.tracks[n_track]\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.add_segmeent","title":"<code>add_segmeent(segment)</code>","text":"<p>Add a new segment ot the track</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>GPXTrackSegment</code> <p>GPXTracksegment to be added</p> required Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def add_segmeent(self, segment: GPXTrackSegment) -&gt; None:\n    \"\"\"Add a new segment ot the track\n\n    :param segment: GPXTracksegment to be added\n    \"\"\"\n    self.track.segments.append(segment)\n    logger.info(\"Added segment with postition: %s\", len(self.track.segments))\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.find_overlap_with_segment","title":"<code>find_overlap_with_segment(n_segment, match_track, match_track_segment=0, width=50, overlap_threshold=0.75, max_queue_normalize=5, merge_subsegments=5, extensions_interpolation='copy-forward')</code>","text":"<p>Find overlap of a segment of the track with a segment in another track.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Segment in the track that sould be used as base for the comparison</p> required <code>match_track</code> <code>Track</code> <p>Track object containing the segment to be matched</p> required <code>match_track_segment</code> <code>int</code> <p>Segment on the passed track that should be matched to the segment in this track, defaults to 0</p> <code>0</code> <code>width</code> <code>float</code> <p>Width (in meters) of the grid that will be filled to estimate the overalp , defaults to 50</p> <code>50</code> <code>overlap_threshold</code> <code>float</code> <p>Minimum overlap (as fracrtion) required to return the overlap data, defaults to 0.75</p> <code>0.75</code> <code>max_queue_normalize</code> <code>int</code> <p>Minimum number of successive points in the segment between two points falling into same plate bin, defaults to 5</p> <code>5</code> <code>merge_subsegments</code> <code>int</code> <p>Number of points between sub segments allowed for merging the segments, defaults to 5</p> <code>5</code> <code>extensions_interpolation</code> <code>Literal['copy-forward', 'meet-center', 'linear']</code> <p>How should the extenstion (if present) be defined in the interpolated points, defaults to copy-forward</p> <code>'copy-forward'</code> <p>Returns:</p> Type Description <code>Sequence[tuple[Track, float, bool]]</code> <p>Tuple containing a Track with the overlapping points, the overlap in percent, and the direction of the overlap</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def find_overlap_with_segment(\n    self,\n    n_segment: int,\n    match_track: Track,\n    match_track_segment: int = 0,\n    width: float = 50,\n    overlap_threshold: float = 0.75,\n    max_queue_normalize: int = 5,\n    merge_subsegments: int = 5,\n    extensions_interpolation: Literal[\n        \"copy-forward\", \"meet-center\", \"linear\"\n    ] = \"copy-forward\",\n) -&gt; Sequence[tuple[Track, float, bool]]:\n    \"\"\"Find overlap of a segment of the track with a segment in another track.\n\n    :param n_segment: Segment in the track that sould be used as base for the\n        comparison\n    :param match_track: Track object containing the segment to be matched\n    :param match_track_segment: Segment on the passed track that should be matched\n        to the segment in this track, defaults to 0\n    :param width: Width (in meters) of the grid that will be filled to estimate\n        the overalp , defaults to 50\n    :param overlap_threshold: Minimum overlap (as fracrtion) required to return the\n        overlap data, defaults to 0.75\n    :param max_queue_normalize: Minimum number of successive points in the segment\n        between two points falling into same plate bin, defaults to 5\n    :param merge_subsegments: Number of points between sub segments allowed\n        for merging the segments, defaults to 5\n    :param extensions_interpolation: How should the extenstion (if present) be\n        defined in the interpolated points, defaults to copy-forward\n\n    :return: Tuple containing a Track with the overlapping points, the overlap in\n        percent, and the direction of the overlap\n    \"\"\"\n    max_distance_self = self.get_max_pp_distance_in_segment(n_segment)\n\n    segment_self = self.track.segments[n_segment]\n    if max_distance_self &gt; width:\n        segment_self = interpolate_segment(\n            segment_self, width / 2, copy_extensions=extensions_interpolation\n        )\n\n    max_distance_match = match_track.get_max_pp_distance_in_segment(\n        match_track_segment\n    )\n    segment_match = match_track.track.segments[match_track_segment]\n    if max_distance_match &gt; width:\n        segment_match = interpolate_segment(\n            segment_match, width / 2, copy_extensions=extensions_interpolation\n        )\n\n    logger.info(\"Looking for overlapping segments\")\n    segment_overlaps = get_segment_overlap(\n        segment_self,\n        segment_match,\n        width,\n        max_queue_normalize,\n        merge_subsegments,\n        overlap_threshold,\n    )\n\n    matched_tracks: list[tuple[Track, float, bool]] = []\n    for overlap in segment_overlaps:\n        logger.info(\"Found: %s\", overlap)\n        matched_segment = GPXTrackSegment()\n        # TODO: Might need to go up to overlap.end_idx + 1?\n        matched_segment.points = self.track.segments[n_segment].points[\n            overlap.start_idx : overlap.end_idx\n        ]\n        matched_tracks.append(\n            (\n                SegmentTrack(\n                    matched_segment,\n                    stopped_speed_threshold=self.stopped_speed_threshold,\n                    max_speed_percentile=self.max_speed_percentile,\n                ),\n                overlap.overlap,\n                overlap.inverse,\n            )\n        )\n    return matched_tracks\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_avg_pp_distance","title":"<code>get_avg_pp_distance(threshold=10)</code>","text":"<p>Get average distance between points in the track.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the average, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Average distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_avg_pp_distance(self, threshold: float = 10) -&gt; float:\n    \"\"\"\n    Get average distance between points in the track.\n\n    :param threshold: Minimum distance between points required to  be used for the\n        average, defaults to 10\n\n    :return: Average distance\n    \"\"\"\n    return self._get_aggregated_pp_distance(\"average\", threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_avg_pp_distance_in_segment","title":"<code>get_avg_pp_distance_in_segment(n_segment=0, threshold=10)</code>","text":"<p>Get average distance between points in the segment with index n_segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement to process, defaults to 0</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the average, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Average distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_avg_pp_distance_in_segment(\n    self, n_segment: int = 0, threshold: float = 10\n) -&gt; float:\n    \"\"\"\n    Get average distance between points in the segment with index n_segment.\n\n    :param n_segment: Index of the segement to process, defaults to 0\n    :param threshold: Minimum distance between points required to  be used for the\n        average, defaults to 10\n\n    :return: Average distance\n    \"\"\"\n    return self._get_aggregated_pp_distance_in_segment(\n        \"average\", n_segment, threshold\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_closest_point","title":"<code>get_closest_point(n_segment, latitude, longitude)</code>","text":"<p>Get closest point in a segment or track to the passed latitude and longitude corrdinate</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>None | int</code> <p>Index of the segment. If None is passed the whole track is considered</p> required <code>latitude</code> <code>float</code> <p>Latitude to check</p> required <code>longitude</code> <code>float</code> <p>Longitude to check</p> required <p>Returns:</p> Type Description <code>PointDistance</code> <p>Tuple containg the point as GPXTrackPoint, the distance from the passed coordinates and the index in the segment</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_closest_point(\n    self, n_segment: None | int, latitude: float, longitude: float\n) -&gt; PointDistance:\n    \"\"\"\n    Get closest point in a segment or track to the passed latitude and longitude\n    corrdinate\n\n    :param n_segment: Index of the segment. If None is passed the whole track is\n        considered\n    :param latitude: Latitude to check\n    :param longitude: Longitude to check\n\n    :return: Tuple containg the point as GPXTrackPoint, the distance from\n        the passed coordinates and the index in the segment\n    \"\"\"\n    return get_point_distance(self.track, n_segment, latitude, longitude)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_max_pp_distance","title":"<code>get_max_pp_distance(threshold=10)</code>","text":"<p>Get maximum distance between points in the track.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the maximum, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Maximum distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_max_pp_distance(self, threshold: float = 10) -&gt; float:\n    \"\"\"\n    Get maximum distance between points in the track.\n\n    :param threshold: Minimum distance between points required to  be used for the\n        maximum, defaults to 10\n\n    :return: Maximum distance\n    \"\"\"\n    return self._get_aggregated_pp_distance(\"max\", threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_max_pp_distance_in_segment","title":"<code>get_max_pp_distance_in_segment(n_segment=0, threshold=10)</code>","text":"<p>Get maximum distance between points in the segment with index n_segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement to process, defaults to 0</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the maximum, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Maximum distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_max_pp_distance_in_segment(\n    self, n_segment: int = 0, threshold: float = 10\n) -&gt; float:\n    \"\"\"\n    Get maximum distance between points in the segment with index n_segment.\n\n    :param n_segment: Index of the segement to process, defaults to 0\n    :param threshold: Minimum distance between points required to  be used for the\n        maximum, defaults to 10\n\n    :return: Maximum distance\n    \"\"\"\n    return self._get_aggregated_pp_distance_in_segment(\"max\", n_segment, threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_point_data_in_segmnet","title":"<code>get_point_data_in_segmnet(n_segment=0)</code>","text":"<p>Get raw coordinates (latitude, longitude), times and elevations for the segement with the passed index.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[list[tuple[float, float]], None | list[float], None | list[datetime]]</code> <p>tuple with coordinates (latitude, longitude), times and elevations</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_point_data_in_segmnet(\n    self, n_segment: int = 0\n) -&gt; tuple[list[tuple[float, float]], None | list[float], None | list[datetime]]:\n    \"\"\"Get raw coordinates (latitude, longitude), times and elevations for the\n    segement with the passed index.\n\n    :param n_segment: Index of the segement, defaults to 0\n\n    :return: tuple with coordinates (latitude, longitude), times and elevations\n    \"\"\"\n    coords = []\n    elevations = []\n    times = []\n\n    for point in self.track.segments[n_segment].points:\n        coords.append((point.latitude, point.longitude))\n        if point.elevation is not None:\n            elevations.append(point.elevation)\n        if point.time is not None:\n            times.append(point.time)\n\n    if not elevations:\n        elevations = None  # type: ignore\n    elif len(coords) != len(elevations):\n        raise TrackTransformationError(\n            \"Elevation is not set for all points. This is not supported\"\n        )\n    if not times:\n        times = None  # type: ignore\n    elif len(coords) != len(times):\n        raise TrackTransformationError(\n            \"Elevation is not set for all points. This is not supported\"\n        )\n\n    return coords, elevations, times\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_segment_data","title":"<code>get_segment_data(n_segment=0)</code>","text":"<p>Get processed data for the segmeent with passed index as DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with segmenet data</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_segment_data(self, n_segment: int = 0) -&gt; pd.DataFrame:\n    \"\"\"Get processed data for the segmeent with passed index as DataFrame\n\n    :param n_segment: Index of the segement, defaults to 0\n\n    :return: DataFrame with segmenet data\n    \"\"\"\n    _, _, _, _, data = self._get_processed_segment_data(n_segment)\n\n    return data\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_segment_overview","title":"<code>get_segment_overview(n_segment=0)</code>","text":"<p>Get overall metrics for a segment</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segment the overview should be generated for, default to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>SegmentOverview</code> <p>A SegmentOverview object containing the metrics moving time and distance, total time and distance, maximum and average speed and elevation and cummulated uphill, downholl elevation</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_segment_overview(self, n_segment: int = 0) -&gt; SegmentOverview:\n    \"\"\"\n    Get overall metrics for a segment\n\n    :param n_segment: Index of the segment the overview should be generated for,\n        default to 0\n\n    :returns: A SegmentOverview object containing the metrics moving time and\n        distance, total time and distance, maximum and average speed and elevation\n        and cummulated uphill, downholl elevation\n    \"\"\"\n    (\n        time,\n        distance,\n        stopped_time,\n        stopped_distance,\n        data,\n    ) = self._get_processed_segment_data(n_segment)\n\n    max_speed = None\n    avg_speed = None\n\n    if self.track.segments[n_segment].has_times():\n        max_speed = data.speed[data.in_speed_percentile].max()\n        avg_speed = data.speed[data.in_speed_percentile].mean()\n\n    return self._create_segment_overview(\n        time=time,\n        distance=distance,\n        stopped_time=stopped_time,\n        stopped_distance=stopped_distance,\n        max_speed=max_speed,\n        avg_speed=avg_speed,\n        data=data,\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_track_data","title":"<code>get_track_data(connect_segments='forward')</code>","text":"<p>Get processed data for the track as DataFrame. Segment are indicated via the segment column.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with track data</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_track_data(\n    self, connect_segments: Literal[\"full\", \"forward\"] = \"forward\"\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Get processed data for the track as DataFrame. Segment are indicated\n    via the segment column.\n\n    :return: DataFrame with track data\n    \"\"\"\n    track_data: None | pd.DataFrame = None\n\n    _, _, _, _, track_data = self._get_processed_track_data(\n        connect_segments=connect_segments\n    )\n\n    return track_data\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_track_overview","title":"<code>get_track_overview(connect_segments='forward')</code>","text":"<p>Get overall metrics for the track. Equivalent to the sum of all segments</p> <p>Returns:</p> Type Description <code>SegmentOverview</code> <p>A SegmentOverview object containing the metrics</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_track_overview(\n    self, connect_segments: Literal[\"full\", \"forward\"] = \"forward\"\n) -&gt; SegmentOverview:\n    \"\"\"\n    Get overall metrics for the track. Equivalent to the sum of all segments\n\n    :return: A SegmentOverview object containing the metrics\n    \"\"\"\n    (\n        track_time,\n        track_distance,\n        track_stopped_time,\n        track_stopped_distance,\n        track_data,\n    ) = self._get_processed_track_data(connect_segments=connect_segments)\n\n    track_max_speed = None\n    track_avg_speed = None\n\n    if all(seg.has_times() for seg in self.track.segments):\n        track_max_speed = track_data.speed[track_data.in_speed_percentile].max()\n        track_avg_speed = track_data.speed[track_data.in_speed_percentile].mean()\n\n    return self._create_segment_overview(\n        time=track_time,\n        distance=track_distance,\n        stopped_time=track_stopped_time,\n        stopped_distance=track_stopped_distance,\n        max_speed=track_max_speed,\n        avg_speed=track_avg_speed,\n        data=track_data,  # type: ignore\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.get_xml","title":"<code>get_xml(name=None, email=None)</code>","text":"<p>Get track as .gpx file data</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>None | str</code> <p>Optional author name to be added to gpx file, defaults to None</p> <code>None</code> <code>email</code> <code>None | str</code> <p>Optional auther e-mail address to be added to the gpx file, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Content of a gpx file</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_xml(self, name: None | str = None, email: None | str = None) -&gt; str:\n    \"\"\"Get track as .gpx file data\n\n    :param name: Optional author name to be added to gpx file, defaults to None\n    :param email: Optional auther e-mail address to be added to the gpx file,\n        defaults to None\n\n    :return: Content of a gpx file\n    \"\"\"\n    gpx = GPX()\n\n    gpx.tracks = [self.track]\n    gpx.author_name = name\n    gpx.author_email = email\n\n    return gpx.to_xml()\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.interpolate_points_in_segment","title":"<code>interpolate_points_in_segment(spacing, n_segment=0, copy_extensions='copy-forward')</code>","text":"<p>Add additdion points to a segment by interpolating along the direct line between each point pair according to the passed spacing parameter. If present, elevation and time will be linearly interpolated. Extensions (Heartrate, Cadence, Power) will be interpolated according to value of copy_extensions. Optionas are:</p> <ul> <li>copy the value from the start point of the interpolation (copy-forward)</li> <li>Use value of start point for first half and last point for second half   (meet-center)</li> <li>Linear interpolation (linear)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>spacing</code> <code>float</code> <p>Minimum distance between points added by the interpolation</p> required <code>n_segment</code> <code>int</code> <p>segment in the track to use, defaults to 0</p> <code>0</code> <code>copy_extensions</code> <code>Literal['copy-forward', 'meet-center', 'linear']</code> <p>How should the extenstion (if present) be defined in the interpolated points.</p> <code>'copy-forward'</code> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def interpolate_points_in_segment(\n    self,\n    spacing: float,\n    n_segment: int = 0,\n    copy_extensions: Literal[\n        \"copy-forward\", \"meet-center\", \"linear\"\n    ] = \"copy-forward\",\n) -&gt; None:\n    \"\"\"\n    Add additdion points to a segment by interpolating along the direct line\n    between each point pair according to the passed spacing parameter. If present,\n    elevation and time will be linearly interpolated. Extensions (Heartrate,\n    Cadence, Power) will be interpolated according to value of copy_extensions.\n    Optionas are:\n\n    - copy the value from the start point of the interpolation (copy-forward)\n    - Use value of start point for first half and last point for second half\n      (meet-center)\n    - Linear interpolation (linear)\n\n\n    :param spacing: Minimum distance between points added by the interpolation\n    :param n_segment: segment in the track to use, defaults to 0\n    :param copy_extensions: How should the extenstion (if present) be defined in the\n        interpolated points.\n    \"\"\"\n    self.track.segments[n_segment] = interpolate_segment(\n        self.track.segments[n_segment], spacing, copy_extensions=copy_extensions\n    )\n\n    # Reset saved processed data\n    for key in self._processed_track_data.keys():\n        self._processed_track_data.pop(key)\n    if n_segment in self._processed_segment_data:\n        logger.debug(\n            \"Deleting saved processed segment data for segment %s\", n_segment\n        )\n        self._processed_segment_data.pop(n_segment)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.plot","title":"<code>plot(kind, *, segment=None, reduce_pp_intervals=None, use_distance_segments=None, **kwargs)</code>","text":"<p>Visualize the full track or a single segment.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Literal['profile', 'profile-slope', 'map-line', 'map-line-enhanced', 'map-segments', 'zone_summary', 'segment_zone_summary', 'segment_box', 'segment_summary']</code> <p>Kind of plot to be generated  - profile: Elevation profile of the track. May be enhanced with additional information like Velocity, Heartrate, Cadence, and Power. Pass keyword args for <code>plot_track_2d</code> - profile-slope: Elevation profile with slopes between points. Use the reduce_pp_intervals argument to reduce the number of slope intervals. Pass keyword args for <code>plot_track_with_slope</code> - map-line: Visualize coordinates on the map. Pass keyword args for <code>plot_track_line_on_map</code> - map-line-enhanced: Visualize coordinates on the map. Enhance with additional information like Elevation, Velocity, Heartrate, Cadence, and Power. Pass keyword args for <code>plot_track_enriched_on_map</code> - map-segments: Visualize coordinates on the map split into segments. Pass keyword args for <code>plot_segments_on_map</code> - zone_summary : Visualize an aggregate (time, distance, speed) value for a metric (heartrate, power, cadence) with defined zones. Pass keyword args for <code>plot_track_zones</code>, <code>aggregate</code> and <code>metric</code> are required. - segment_zone_summary : Same as \"zone_summary\" but split aggregate per segment <code>plot_segment_zones</code> - segment_box : Box plot of a metric (heartrate, power, cadence, speed, elevation) per segment. Pass keyword args for <code>plot_segments_on_map</code> <code>metric</code> is required. - segment_summary : Visualize a aggregate (total_time, total_distance, avg_speed, max_speed) per segment. Pass keyword args for <code>plot_segment_summary</code> <code>aggregate</code> is required.</p> required <code>segment</code> <code>None | int | list[int]</code> <p>Select a specific segment, multiple segments or all segmenets, defaults to None</p> <code>None</code> <code>reduce_pp_intervals</code> <code>None | int</code> <p>Optionally pass a distance in m which is used to reduce the points in a track, defaults to None</p> <code>None</code> <code>use_distance_segments</code> <code>None | float</code> <p>Ignore all segments in data and split full track into segments with passed cummulated distance in meters. If passed, segment arg must be None. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Figure (plotly)</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>If the plot prequisites are not met</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def plot(\n    self,\n    kind: Literal[\n        \"profile\",\n        \"profile-slope\",\n        \"map-line\",\n        \"map-line-enhanced\",\n        \"map-segments\",\n        \"zone_summary\",\n        \"segment_zone_summary\",\n        \"segment_box\",\n        \"segment_summary\",\n    ],\n    *,\n    segment: None | int | list[int] = None,\n    reduce_pp_intervals: None | int = None,\n    use_distance_segments: None | float = None,\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"\n    Visualize the full track or a single segment.\n\n    :param kind: Kind of plot to be generated\n\n        - profile: Elevation profile of the track. May be enhanced with additional\n          information like Velocity, Heartrate, Cadence, and Power. Pass keyword\n          args for [`plot_track_2d`][geo_track_analyzer.visualize.plot_track_2d]\n        - profile-slope: Elevation profile with slopes between points. Use the\n          reduce_pp_intervals argument to reduce the number of slope intervals.\n          Pass keyword args for\n          [`plot_track_with_slope`][geo_track_analyzer.visualize.plot_track_with_slope]\n        - map-line: Visualize coordinates on the map. Pass keyword args for\n          [`plot_track_line_on_map`][geo_track_analyzer.visualize.plot_track_line_on_map]\n        - map-line-enhanced: Visualize coordinates on the map. Enhance with\n          additional information like Elevation, Velocity, Heartrate, Cadence, and\n          Power. Pass keyword args for [`plot_track_enriched_on_map`][geo_track_analyzer.visualize.plot_track_enriched_on_map]\n        - map-segments: Visualize coordinates on the map split into segments.\n          Pass keyword args for\n          [`plot_segments_on_map`][geo_track_analyzer.visualize.plot_segments_on_map]\n        - zone_summary : Visualize an aggregate (time, distance, speed) value for a\n            metric (heartrate, power, cadence) with defined zones. Pass keyword args\n            for [`plot_track_zones`][geo_track_analyzer.visualize.plot_track_zones],\n            `aggregate` and `metric` are required.\n        - segment_zone_summary : Same as \"zone_summary\" but split aggregate per\n            segment [`plot_segment_zones`][geo_track_analyzer.visualize.plot_segment_zones]\n        - segment_box : Box plot of a metric (heartrate, power, cadence, speed,\n            elevation) per segment. Pass keyword args for [`plot_segments_on_map`][geo_track_analyzer.visualize.plot_segments_on_map]\n            `metric` is required.\n        - segment_summary : Visualize a aggregate (total_time, total_distance,\n            avg_speed, max_speed) per segment. Pass keyword args for [`plot_segment_summary`][geo_track_analyzer.visualize.plot_segment_summary]\n            `aggregate` is required.\n    :param segment: Select a specific segment, multiple segments or all segmenets,\n        defaults to None\n    :param reduce_pp_intervals: Optionally pass a distance in m which is used to\n        reduce the points in a track, defaults to None\n    :param use_distance_segments: Ignore all segments in data and split full track\n        into segments with passed cummulated distance in meters. If passed, segment\n        arg must be None. Defaults to None.\n    :raises VisualizationSetupError: If the plot prequisites are not met\n\n    :return: Figure (plotly)\n    \"\"\"\n    from geo_track_analyzer.utils.track import generate_distance_segments\n\n    if use_distance_segments is not None and segment is not None:\n        raise VisualizationSetupError(\n            f\"use_distance_segments {use_distance_segments} cannot be passed with \"\n            f\"segment {segment}.\"\n        )\n\n    valid_kinds = [\n        \"profile\",\n        \"profile-slope\",\n        \"map-line\",\n        \"map-line-enhanced\",\n        \"map-segments\",\n        \"zone_summary\",\n        \"segment_zone_summary\",\n        \"segment_box\",\n        \"segment_summary\",\n    ]\n\n    require_elevation = [\"profile\", \"profile-slope\"]\n    connect_segment_full = [\"map-segments\"]\n    if kind not in valid_kinds:\n        raise VisualizationSetupError(\n            f\"Kind {kind} is not valid. Pass on of {','.join(valid_kinds)}\"\n        )\n\n    if kind in [\"zone_summary\", \"segment_zone_summary\"] and not all(\n        key in kwargs.keys() for key in [\"metric\", \"aggregate\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** and **aggregate** need to be passed\"\n        )\n    if kind in [\"segment_box\"] and not all(\n        key in kwargs.keys() for key in [\"metric\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** needs to be passed\"\n        )\n    if kind in [\"segment_summary\"] and not all(\n        key in kwargs.keys() for key in [\"aggregate\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** needs to be passed\"\n        )\n\n    if segment is None:\n        from geo_track_analyzer.utils.track import extract_track_data_for_plot\n\n        data = extract_track_data_for_plot(\n            track=self,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n            connect_segments=\"full\" if kind in connect_segment_full else \"forward\",\n        )\n    elif isinstance(segment, int):\n        from geo_track_analyzer.utils.track import extract_segment_data_for_plot\n\n        data = extract_segment_data_for_plot(\n            track=self,\n            segment=segment,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n        )\n    else:\n        from geo_track_analyzer.utils.track import (\n            extract_multiple_segment_data_for_plot,\n        )\n\n        data = extract_multiple_segment_data_for_plot(\n            track=self,\n            segments=segment,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n        )\n\n    if use_distance_segments is not None:\n        data = generate_distance_segments(data, use_distance_segments)\n\n    fig: Figure\n    if kind == \"profile\":\n        fig = plot_track_2d(data=data, **kwargs)\n    elif kind == \"profile-slope\":\n        fig = plot_track_with_slope(data=data, **kwargs)\n    elif kind == \"map-line\":\n        fig = plot_track_line_on_map(data=data, **kwargs)\n    elif kind == \"map-line-enhanced\":\n        fig = plot_track_enriched_on_map(data=data, **kwargs)\n    elif kind == \"map-segments\":\n        fig = plot_segments_on_map(data=data, **kwargs)\n    elif kind == \"zone_summary\":\n        fig = plot_track_zones(data=data, **kwargs)\n    elif kind == \"segment_zone_summary\":\n        fig = plot_segment_zones(data=data, **kwargs)\n    elif kind == \"segment_summary\":\n        fig = plot_segment_summary(data=data, **kwargs)\n    elif kind == \"segment_box\":\n        fig = plot_segment_box_summary(data=data, **kwargs)\n\n    return fig\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.GPXFileTrack.split","title":"<code>split(coords, distance_threshold=20)</code>","text":"<p>Split the track at the passed coordinates. The distance_threshold parameter defines the maximum distance between the passed coordingates and the closest point in the track.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>tuple[float, float]</code> <p>Latitude, Longitude point at which the split should be made</p> required <code>distance_threshold</code> <code>float</code> <p>Maximum distance between coords and closest point, defaults to 20</p> <code>20</code> <p>Raises:</p> Type Description <code>TrackTransformationError</code> <p>If distance exceeds threshold</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def split(\n    self, coords: tuple[float, float], distance_threshold: float = 20\n) -&gt; None:\n    \"\"\"\n    Split the track at the passed coordinates. The distance_threshold parameter\n    defines the maximum distance between the passed coordingates and the closest\n    point in the track.\n\n    :param coords: Latitude, Longitude point at which the split should be made\n    :param distance_threshold: Maximum distance between coords and closest point,\n        defaults to 20\n\n    :raises TrackTransformationError: If distance exceeds threshold\n    \"\"\"\n    lat, long = coords\n    point_distance = get_point_distance(\n        self.track, None, latitude=lat, longitude=long\n    )\n\n    if point_distance.distance &gt; distance_threshold:\n        raise TrackTransformationError(\n            f\"Closes point in track has distance {point_distance.distance:.2f}m \"\n            \"from passed coordingates\"\n        )\n    # Split the segment. The closest point should be the first\n    # point of the second segment\n    pre_segment, post_segment = self.track.segments[\n        point_distance.segment_idx\n    ].split(point_distance.segment_point_idx - 1)\n\n    self.track.segments[point_distance.segment_idx] = pre_segment\n    self.track.segments.insert(point_distance.segment_idx + 1, post_segment)\n\n    self._processed_segment_data = {}\n    self._processed_track_data = {}\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack","title":"<code>FITTrack(source, stopped_speed_threshold=1, max_speed_percentile=95, strict_elevation_loading=False, heartrate_zones=None, power_zones=None, cadence_zones=None)</code>","text":"<p>             Bases: <code>Track</code></p> <p>Track that should be initialized by loading a .fit file</p> <p>Load a .fit file and extract the data into a Track object. NOTE: Tested with Wahoo devices only</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | bytes</code> <p>Patch to fit file or byte representation of fit file</p> required <code>stopped_speed_threshold</code> <code>float</code> <p>Minium speed required for a point to be count as moving, defaults to 1</p> <code>1</code> <code>max_speed_percentile</code> <code>int</code> <p>Points with speed outside of the percentile are not counted when analyzing the track, defaults to 95</p> <code>95</code> <code>strict_elevation_loading</code> <code>bool</code> <p>If set, only points are added to the track that have a valid elevation,defaults to False</p> <code>False</code> <code>heartrate_zones</code> <code>None | Zones</code> <p>Optional heartrate Zones, defaults to None</p> <code>None</code> <code>power_zones</code> <code>None | Zones</code> <p>Optional power Zones, defaults to None</p> <code>None</code> <code>cadence_zones</code> <code>None | Zones</code> <p>Optional cadence Zones, defaults to None</p> <code>None</code> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def __init__(\n    self,\n    source: str | bytes,\n    stopped_speed_threshold: float = 1,\n    max_speed_percentile: int = 95,\n    strict_elevation_loading: bool = False,\n    heartrate_zones: None | Zones = None,\n    power_zones: None | Zones = None,\n    cadence_zones: None | Zones = None,\n) -&gt; None:\n    \"\"\"Load a .fit file and extract the data into a Track object.\n    NOTE: Tested with Wahoo devices only\n\n    :param source: Patch to fit file or byte representation of fit file\n    :param stopped_speed_threshold: Minium speed required for a point to be count\n        as moving, defaults to 1\n    :param max_speed_percentile: Points with speed outside of the percentile are not\n        counted when analyzing the track, defaults to 95\n    :param strict_elevation_loading: If set, only points are added to the track that\n        have a valid elevation,defaults to False\n    :param heartrate_zones: Optional heartrate Zones, defaults to None\n    :param power_zones: Optional power Zones, defaults to None\n    :param cadence_zones: Optional cadence Zones, defaults to None\n    \"\"\"\n    super().__init__(\n        stopped_speed_threshold=stopped_speed_threshold,\n        max_speed_percentile=max_speed_percentile,\n        heartrate_zones=heartrate_zones,\n        power_zones=power_zones,\n        cadence_zones=cadence_zones,\n    )\n\n    if isinstance(source, str):\n        logger.info(\"Loading fit track from file %s\", source)\n    else:\n        logger.info(\"Using passed bytes data as fit track\")\n\n    fit_data = FitFile(\n        source,\n        data_processor=StandardUnitsDataProcessor(),\n    )\n\n    points, elevations, times = [], [], []\n    heartrates, cadences, powers = [], [], []\n\n    split_at = [0]\n    for record in fit_data.get_messages((\"record\", \"lap\")):  # type: ignore\n        record: DataMessage  # type: ignore\n        if record.mesg_type.name == \"lap\":\n            split_at.append(len(points))\n        lat = record.get_value(\"position_lat\")\n        long = record.get_value(\"position_long\")\n        ele = record.get_value(\"enhanced_altitude\")\n        ts = record.get_value(\"timestamp\")\n\n        hr = record.get_value(\"heart_rate\")\n        cad = record.get_value(\"cadence\")\n        pw = record.get_value(\"power\")\n\n        check_vals = [lat, long, ts]\n        if strict_elevation_loading:\n            check_vals.append(ele)\n\n        if any([v is None for v in check_vals]):\n            logger.debug(\n                \"Found records with None value in lat/long/elevation/timestamp \"\n                \" - %s/%s/%s/%s\",\n                lat,\n                long,\n                ele,\n                ts,\n            )\n            continue\n\n        points.append((lat, long))\n        elevations.append(ele)\n        times.append(ts)\n\n        heartrates.append(hr)\n        cadences.append(cad)\n        powers.append(pw)\n\n    if not strict_elevation_loading and set(elevations) != {None}:\n        elevations = fill_list(elevations)\n\n    try:\n        session_data: DataMessage = list(fit_data.get_messages(\"session\"))[-1]  # type: ignore\n    except IndexError:\n        logger.debug(\"Could not load session data from fit file\")\n    else:\n        self.session_data = {  # type: ignore\n            \"start_time\": session_data.get_value(\"start_time\"),\n            \"ride_time\": session_data.get_value(\"total_timer_time\"),\n            \"total_time\": session_data.get_value(\"total_elapsed_time\"),\n            \"distance\": session_data.get_value(\"total_distance\"),\n            \"ascent\": session_data.get_value(\"total_ascent\"),\n            \"descent\": session_data.get_value(\"total_descent\"),\n            \"avg_velocity\": session_data.get_value(\"avg_speed\"),\n            \"max_velocity\": session_data.get_value(\"max_speed\"),\n        }\n\n    if len(split_at) == 1:\n        split_at.append(len(points))\n\n    gpx = GPX()\n\n    gpx_track = GPXTrack()\n    gpx.tracks.append(gpx_track)\n\n    for start_idx, end_idx in pairwise(split_at):\n        gpx_segment = GPXTrackSegment()\n\n        for (lat, lng), ele, time, hr, cad, pw in zip(\n            points[start_idx:end_idx],\n            elevations[start_idx:end_idx],\n            times[start_idx:end_idx],\n            heartrates[start_idx:end_idx],\n            cadences[start_idx:end_idx],\n            powers[start_idx:end_idx],\n        ):\n            this_extensions = {}\n            if hr is not None:\n                this_extensions[\"heartrate\"] = hr\n            if cad is not None:\n                this_extensions[\"cadence\"] = cad\n            if pw is not None:\n                this_extensions[\"power\"] = pw\n            this_point = get_extended_track_point(\n                lat, lng, ele, time, this_extensions\n            )\n\n            gpx_segment.points.append(this_point)\n\n        gpx_track.segments.append(gpx_segment)\n\n    self._track = gpx.tracks[0]\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.add_segmeent","title":"<code>add_segmeent(segment)</code>","text":"<p>Add a new segment ot the track</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>GPXTrackSegment</code> <p>GPXTracksegment to be added</p> required Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def add_segmeent(self, segment: GPXTrackSegment) -&gt; None:\n    \"\"\"Add a new segment ot the track\n\n    :param segment: GPXTracksegment to be added\n    \"\"\"\n    self.track.segments.append(segment)\n    logger.info(\"Added segment with postition: %s\", len(self.track.segments))\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.find_overlap_with_segment","title":"<code>find_overlap_with_segment(n_segment, match_track, match_track_segment=0, width=50, overlap_threshold=0.75, max_queue_normalize=5, merge_subsegments=5, extensions_interpolation='copy-forward')</code>","text":"<p>Find overlap of a segment of the track with a segment in another track.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Segment in the track that sould be used as base for the comparison</p> required <code>match_track</code> <code>Track</code> <p>Track object containing the segment to be matched</p> required <code>match_track_segment</code> <code>int</code> <p>Segment on the passed track that should be matched to the segment in this track, defaults to 0</p> <code>0</code> <code>width</code> <code>float</code> <p>Width (in meters) of the grid that will be filled to estimate the overalp , defaults to 50</p> <code>50</code> <code>overlap_threshold</code> <code>float</code> <p>Minimum overlap (as fracrtion) required to return the overlap data, defaults to 0.75</p> <code>0.75</code> <code>max_queue_normalize</code> <code>int</code> <p>Minimum number of successive points in the segment between two points falling into same plate bin, defaults to 5</p> <code>5</code> <code>merge_subsegments</code> <code>int</code> <p>Number of points between sub segments allowed for merging the segments, defaults to 5</p> <code>5</code> <code>extensions_interpolation</code> <code>Literal['copy-forward', 'meet-center', 'linear']</code> <p>How should the extenstion (if present) be defined in the interpolated points, defaults to copy-forward</p> <code>'copy-forward'</code> <p>Returns:</p> Type Description <code>Sequence[tuple[Track, float, bool]]</code> <p>Tuple containing a Track with the overlapping points, the overlap in percent, and the direction of the overlap</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def find_overlap_with_segment(\n    self,\n    n_segment: int,\n    match_track: Track,\n    match_track_segment: int = 0,\n    width: float = 50,\n    overlap_threshold: float = 0.75,\n    max_queue_normalize: int = 5,\n    merge_subsegments: int = 5,\n    extensions_interpolation: Literal[\n        \"copy-forward\", \"meet-center\", \"linear\"\n    ] = \"copy-forward\",\n) -&gt; Sequence[tuple[Track, float, bool]]:\n    \"\"\"Find overlap of a segment of the track with a segment in another track.\n\n    :param n_segment: Segment in the track that sould be used as base for the\n        comparison\n    :param match_track: Track object containing the segment to be matched\n    :param match_track_segment: Segment on the passed track that should be matched\n        to the segment in this track, defaults to 0\n    :param width: Width (in meters) of the grid that will be filled to estimate\n        the overalp , defaults to 50\n    :param overlap_threshold: Minimum overlap (as fracrtion) required to return the\n        overlap data, defaults to 0.75\n    :param max_queue_normalize: Minimum number of successive points in the segment\n        between two points falling into same plate bin, defaults to 5\n    :param merge_subsegments: Number of points between sub segments allowed\n        for merging the segments, defaults to 5\n    :param extensions_interpolation: How should the extenstion (if present) be\n        defined in the interpolated points, defaults to copy-forward\n\n    :return: Tuple containing a Track with the overlapping points, the overlap in\n        percent, and the direction of the overlap\n    \"\"\"\n    max_distance_self = self.get_max_pp_distance_in_segment(n_segment)\n\n    segment_self = self.track.segments[n_segment]\n    if max_distance_self &gt; width:\n        segment_self = interpolate_segment(\n            segment_self, width / 2, copy_extensions=extensions_interpolation\n        )\n\n    max_distance_match = match_track.get_max_pp_distance_in_segment(\n        match_track_segment\n    )\n    segment_match = match_track.track.segments[match_track_segment]\n    if max_distance_match &gt; width:\n        segment_match = interpolate_segment(\n            segment_match, width / 2, copy_extensions=extensions_interpolation\n        )\n\n    logger.info(\"Looking for overlapping segments\")\n    segment_overlaps = get_segment_overlap(\n        segment_self,\n        segment_match,\n        width,\n        max_queue_normalize,\n        merge_subsegments,\n        overlap_threshold,\n    )\n\n    matched_tracks: list[tuple[Track, float, bool]] = []\n    for overlap in segment_overlaps:\n        logger.info(\"Found: %s\", overlap)\n        matched_segment = GPXTrackSegment()\n        # TODO: Might need to go up to overlap.end_idx + 1?\n        matched_segment.points = self.track.segments[n_segment].points[\n            overlap.start_idx : overlap.end_idx\n        ]\n        matched_tracks.append(\n            (\n                SegmentTrack(\n                    matched_segment,\n                    stopped_speed_threshold=self.stopped_speed_threshold,\n                    max_speed_percentile=self.max_speed_percentile,\n                ),\n                overlap.overlap,\n                overlap.inverse,\n            )\n        )\n    return matched_tracks\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_avg_pp_distance","title":"<code>get_avg_pp_distance(threshold=10)</code>","text":"<p>Get average distance between points in the track.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the average, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Average distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_avg_pp_distance(self, threshold: float = 10) -&gt; float:\n    \"\"\"\n    Get average distance between points in the track.\n\n    :param threshold: Minimum distance between points required to  be used for the\n        average, defaults to 10\n\n    :return: Average distance\n    \"\"\"\n    return self._get_aggregated_pp_distance(\"average\", threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_avg_pp_distance_in_segment","title":"<code>get_avg_pp_distance_in_segment(n_segment=0, threshold=10)</code>","text":"<p>Get average distance between points in the segment with index n_segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement to process, defaults to 0</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the average, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Average distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_avg_pp_distance_in_segment(\n    self, n_segment: int = 0, threshold: float = 10\n) -&gt; float:\n    \"\"\"\n    Get average distance between points in the segment with index n_segment.\n\n    :param n_segment: Index of the segement to process, defaults to 0\n    :param threshold: Minimum distance between points required to  be used for the\n        average, defaults to 10\n\n    :return: Average distance\n    \"\"\"\n    return self._get_aggregated_pp_distance_in_segment(\n        \"average\", n_segment, threshold\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_closest_point","title":"<code>get_closest_point(n_segment, latitude, longitude)</code>","text":"<p>Get closest point in a segment or track to the passed latitude and longitude corrdinate</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>None | int</code> <p>Index of the segment. If None is passed the whole track is considered</p> required <code>latitude</code> <code>float</code> <p>Latitude to check</p> required <code>longitude</code> <code>float</code> <p>Longitude to check</p> required <p>Returns:</p> Type Description <code>PointDistance</code> <p>Tuple containg the point as GPXTrackPoint, the distance from the passed coordinates and the index in the segment</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_closest_point(\n    self, n_segment: None | int, latitude: float, longitude: float\n) -&gt; PointDistance:\n    \"\"\"\n    Get closest point in a segment or track to the passed latitude and longitude\n    corrdinate\n\n    :param n_segment: Index of the segment. If None is passed the whole track is\n        considered\n    :param latitude: Latitude to check\n    :param longitude: Longitude to check\n\n    :return: Tuple containg the point as GPXTrackPoint, the distance from\n        the passed coordinates and the index in the segment\n    \"\"\"\n    return get_point_distance(self.track, n_segment, latitude, longitude)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_max_pp_distance","title":"<code>get_max_pp_distance(threshold=10)</code>","text":"<p>Get maximum distance between points in the track.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the maximum, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Maximum distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_max_pp_distance(self, threshold: float = 10) -&gt; float:\n    \"\"\"\n    Get maximum distance between points in the track.\n\n    :param threshold: Minimum distance between points required to  be used for the\n        maximum, defaults to 10\n\n    :return: Maximum distance\n    \"\"\"\n    return self._get_aggregated_pp_distance(\"max\", threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_max_pp_distance_in_segment","title":"<code>get_max_pp_distance_in_segment(n_segment=0, threshold=10)</code>","text":"<p>Get maximum distance between points in the segment with index n_segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement to process, defaults to 0</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the maximum, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Maximum distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_max_pp_distance_in_segment(\n    self, n_segment: int = 0, threshold: float = 10\n) -&gt; float:\n    \"\"\"\n    Get maximum distance between points in the segment with index n_segment.\n\n    :param n_segment: Index of the segement to process, defaults to 0\n    :param threshold: Minimum distance between points required to  be used for the\n        maximum, defaults to 10\n\n    :return: Maximum distance\n    \"\"\"\n    return self._get_aggregated_pp_distance_in_segment(\"max\", n_segment, threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_point_data_in_segmnet","title":"<code>get_point_data_in_segmnet(n_segment=0)</code>","text":"<p>Get raw coordinates (latitude, longitude), times and elevations for the segement with the passed index.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[list[tuple[float, float]], None | list[float], None | list[datetime]]</code> <p>tuple with coordinates (latitude, longitude), times and elevations</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_point_data_in_segmnet(\n    self, n_segment: int = 0\n) -&gt; tuple[list[tuple[float, float]], None | list[float], None | list[datetime]]:\n    \"\"\"Get raw coordinates (latitude, longitude), times and elevations for the\n    segement with the passed index.\n\n    :param n_segment: Index of the segement, defaults to 0\n\n    :return: tuple with coordinates (latitude, longitude), times and elevations\n    \"\"\"\n    coords = []\n    elevations = []\n    times = []\n\n    for point in self.track.segments[n_segment].points:\n        coords.append((point.latitude, point.longitude))\n        if point.elevation is not None:\n            elevations.append(point.elevation)\n        if point.time is not None:\n            times.append(point.time)\n\n    if not elevations:\n        elevations = None  # type: ignore\n    elif len(coords) != len(elevations):\n        raise TrackTransformationError(\n            \"Elevation is not set for all points. This is not supported\"\n        )\n    if not times:\n        times = None  # type: ignore\n    elif len(coords) != len(times):\n        raise TrackTransformationError(\n            \"Elevation is not set for all points. This is not supported\"\n        )\n\n    return coords, elevations, times\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_segment_data","title":"<code>get_segment_data(n_segment=0)</code>","text":"<p>Get processed data for the segmeent with passed index as DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with segmenet data</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_segment_data(self, n_segment: int = 0) -&gt; pd.DataFrame:\n    \"\"\"Get processed data for the segmeent with passed index as DataFrame\n\n    :param n_segment: Index of the segement, defaults to 0\n\n    :return: DataFrame with segmenet data\n    \"\"\"\n    _, _, _, _, data = self._get_processed_segment_data(n_segment)\n\n    return data\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_segment_overview","title":"<code>get_segment_overview(n_segment=0)</code>","text":"<p>Get overall metrics for a segment</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segment the overview should be generated for, default to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>SegmentOverview</code> <p>A SegmentOverview object containing the metrics moving time and distance, total time and distance, maximum and average speed and elevation and cummulated uphill, downholl elevation</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_segment_overview(self, n_segment: int = 0) -&gt; SegmentOverview:\n    \"\"\"\n    Get overall metrics for a segment\n\n    :param n_segment: Index of the segment the overview should be generated for,\n        default to 0\n\n    :returns: A SegmentOverview object containing the metrics moving time and\n        distance, total time and distance, maximum and average speed and elevation\n        and cummulated uphill, downholl elevation\n    \"\"\"\n    (\n        time,\n        distance,\n        stopped_time,\n        stopped_distance,\n        data,\n    ) = self._get_processed_segment_data(n_segment)\n\n    max_speed = None\n    avg_speed = None\n\n    if self.track.segments[n_segment].has_times():\n        max_speed = data.speed[data.in_speed_percentile].max()\n        avg_speed = data.speed[data.in_speed_percentile].mean()\n\n    return self._create_segment_overview(\n        time=time,\n        distance=distance,\n        stopped_time=stopped_time,\n        stopped_distance=stopped_distance,\n        max_speed=max_speed,\n        avg_speed=avg_speed,\n        data=data,\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_track_data","title":"<code>get_track_data(connect_segments='forward')</code>","text":"<p>Get processed data for the track as DataFrame. Segment are indicated via the segment column.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with track data</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_track_data(\n    self, connect_segments: Literal[\"full\", \"forward\"] = \"forward\"\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Get processed data for the track as DataFrame. Segment are indicated\n    via the segment column.\n\n    :return: DataFrame with track data\n    \"\"\"\n    track_data: None | pd.DataFrame = None\n\n    _, _, _, _, track_data = self._get_processed_track_data(\n        connect_segments=connect_segments\n    )\n\n    return track_data\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_track_overview","title":"<code>get_track_overview(connect_segments='forward')</code>","text":"<p>Get overall metrics for the track. Equivalent to the sum of all segments</p> <p>Returns:</p> Type Description <code>SegmentOverview</code> <p>A SegmentOverview object containing the metrics</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_track_overview(\n    self, connect_segments: Literal[\"full\", \"forward\"] = \"forward\"\n) -&gt; SegmentOverview:\n    \"\"\"\n    Get overall metrics for the track. Equivalent to the sum of all segments\n\n    :return: A SegmentOverview object containing the metrics\n    \"\"\"\n    (\n        track_time,\n        track_distance,\n        track_stopped_time,\n        track_stopped_distance,\n        track_data,\n    ) = self._get_processed_track_data(connect_segments=connect_segments)\n\n    track_max_speed = None\n    track_avg_speed = None\n\n    if all(seg.has_times() for seg in self.track.segments):\n        track_max_speed = track_data.speed[track_data.in_speed_percentile].max()\n        track_avg_speed = track_data.speed[track_data.in_speed_percentile].mean()\n\n    return self._create_segment_overview(\n        time=track_time,\n        distance=track_distance,\n        stopped_time=track_stopped_time,\n        stopped_distance=track_stopped_distance,\n        max_speed=track_max_speed,\n        avg_speed=track_avg_speed,\n        data=track_data,  # type: ignore\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.get_xml","title":"<code>get_xml(name=None, email=None)</code>","text":"<p>Get track as .gpx file data</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>None | str</code> <p>Optional author name to be added to gpx file, defaults to None</p> <code>None</code> <code>email</code> <code>None | str</code> <p>Optional auther e-mail address to be added to the gpx file, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Content of a gpx file</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_xml(self, name: None | str = None, email: None | str = None) -&gt; str:\n    \"\"\"Get track as .gpx file data\n\n    :param name: Optional author name to be added to gpx file, defaults to None\n    :param email: Optional auther e-mail address to be added to the gpx file,\n        defaults to None\n\n    :return: Content of a gpx file\n    \"\"\"\n    gpx = GPX()\n\n    gpx.tracks = [self.track]\n    gpx.author_name = name\n    gpx.author_email = email\n\n    return gpx.to_xml()\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.interpolate_points_in_segment","title":"<code>interpolate_points_in_segment(spacing, n_segment=0, copy_extensions='copy-forward')</code>","text":"<p>Add additdion points to a segment by interpolating along the direct line between each point pair according to the passed spacing parameter. If present, elevation and time will be linearly interpolated. Extensions (Heartrate, Cadence, Power) will be interpolated according to value of copy_extensions. Optionas are:</p> <ul> <li>copy the value from the start point of the interpolation (copy-forward)</li> <li>Use value of start point for first half and last point for second half   (meet-center)</li> <li>Linear interpolation (linear)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>spacing</code> <code>float</code> <p>Minimum distance between points added by the interpolation</p> required <code>n_segment</code> <code>int</code> <p>segment in the track to use, defaults to 0</p> <code>0</code> <code>copy_extensions</code> <code>Literal['copy-forward', 'meet-center', 'linear']</code> <p>How should the extenstion (if present) be defined in the interpolated points.</p> <code>'copy-forward'</code> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def interpolate_points_in_segment(\n    self,\n    spacing: float,\n    n_segment: int = 0,\n    copy_extensions: Literal[\n        \"copy-forward\", \"meet-center\", \"linear\"\n    ] = \"copy-forward\",\n) -&gt; None:\n    \"\"\"\n    Add additdion points to a segment by interpolating along the direct line\n    between each point pair according to the passed spacing parameter. If present,\n    elevation and time will be linearly interpolated. Extensions (Heartrate,\n    Cadence, Power) will be interpolated according to value of copy_extensions.\n    Optionas are:\n\n    - copy the value from the start point of the interpolation (copy-forward)\n    - Use value of start point for first half and last point for second half\n      (meet-center)\n    - Linear interpolation (linear)\n\n\n    :param spacing: Minimum distance between points added by the interpolation\n    :param n_segment: segment in the track to use, defaults to 0\n    :param copy_extensions: How should the extenstion (if present) be defined in the\n        interpolated points.\n    \"\"\"\n    self.track.segments[n_segment] = interpolate_segment(\n        self.track.segments[n_segment], spacing, copy_extensions=copy_extensions\n    )\n\n    # Reset saved processed data\n    for key in self._processed_track_data.keys():\n        self._processed_track_data.pop(key)\n    if n_segment in self._processed_segment_data:\n        logger.debug(\n            \"Deleting saved processed segment data for segment %s\", n_segment\n        )\n        self._processed_segment_data.pop(n_segment)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.plot","title":"<code>plot(kind, *, segment=None, reduce_pp_intervals=None, use_distance_segments=None, **kwargs)</code>","text":"<p>Visualize the full track or a single segment.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Literal['profile', 'profile-slope', 'map-line', 'map-line-enhanced', 'map-segments', 'zone_summary', 'segment_zone_summary', 'segment_box', 'segment_summary']</code> <p>Kind of plot to be generated  - profile: Elevation profile of the track. May be enhanced with additional information like Velocity, Heartrate, Cadence, and Power. Pass keyword args for <code>plot_track_2d</code> - profile-slope: Elevation profile with slopes between points. Use the reduce_pp_intervals argument to reduce the number of slope intervals. Pass keyword args for <code>plot_track_with_slope</code> - map-line: Visualize coordinates on the map. Pass keyword args for <code>plot_track_line_on_map</code> - map-line-enhanced: Visualize coordinates on the map. Enhance with additional information like Elevation, Velocity, Heartrate, Cadence, and Power. Pass keyword args for <code>plot_track_enriched_on_map</code> - map-segments: Visualize coordinates on the map split into segments. Pass keyword args for <code>plot_segments_on_map</code> - zone_summary : Visualize an aggregate (time, distance, speed) value for a metric (heartrate, power, cadence) with defined zones. Pass keyword args for <code>plot_track_zones</code>, <code>aggregate</code> and <code>metric</code> are required. - segment_zone_summary : Same as \"zone_summary\" but split aggregate per segment <code>plot_segment_zones</code> - segment_box : Box plot of a metric (heartrate, power, cadence, speed, elevation) per segment. Pass keyword args for <code>plot_segments_on_map</code> <code>metric</code> is required. - segment_summary : Visualize a aggregate (total_time, total_distance, avg_speed, max_speed) per segment. Pass keyword args for <code>plot_segment_summary</code> <code>aggregate</code> is required.</p> required <code>segment</code> <code>None | int | list[int]</code> <p>Select a specific segment, multiple segments or all segmenets, defaults to None</p> <code>None</code> <code>reduce_pp_intervals</code> <code>None | int</code> <p>Optionally pass a distance in m which is used to reduce the points in a track, defaults to None</p> <code>None</code> <code>use_distance_segments</code> <code>None | float</code> <p>Ignore all segments in data and split full track into segments with passed cummulated distance in meters. If passed, segment arg must be None. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Figure (plotly)</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>If the plot prequisites are not met</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def plot(\n    self,\n    kind: Literal[\n        \"profile\",\n        \"profile-slope\",\n        \"map-line\",\n        \"map-line-enhanced\",\n        \"map-segments\",\n        \"zone_summary\",\n        \"segment_zone_summary\",\n        \"segment_box\",\n        \"segment_summary\",\n    ],\n    *,\n    segment: None | int | list[int] = None,\n    reduce_pp_intervals: None | int = None,\n    use_distance_segments: None | float = None,\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"\n    Visualize the full track or a single segment.\n\n    :param kind: Kind of plot to be generated\n\n        - profile: Elevation profile of the track. May be enhanced with additional\n          information like Velocity, Heartrate, Cadence, and Power. Pass keyword\n          args for [`plot_track_2d`][geo_track_analyzer.visualize.plot_track_2d]\n        - profile-slope: Elevation profile with slopes between points. Use the\n          reduce_pp_intervals argument to reduce the number of slope intervals.\n          Pass keyword args for\n          [`plot_track_with_slope`][geo_track_analyzer.visualize.plot_track_with_slope]\n        - map-line: Visualize coordinates on the map. Pass keyword args for\n          [`plot_track_line_on_map`][geo_track_analyzer.visualize.plot_track_line_on_map]\n        - map-line-enhanced: Visualize coordinates on the map. Enhance with\n          additional information like Elevation, Velocity, Heartrate, Cadence, and\n          Power. Pass keyword args for [`plot_track_enriched_on_map`][geo_track_analyzer.visualize.plot_track_enriched_on_map]\n        - map-segments: Visualize coordinates on the map split into segments.\n          Pass keyword args for\n          [`plot_segments_on_map`][geo_track_analyzer.visualize.plot_segments_on_map]\n        - zone_summary : Visualize an aggregate (time, distance, speed) value for a\n            metric (heartrate, power, cadence) with defined zones. Pass keyword args\n            for [`plot_track_zones`][geo_track_analyzer.visualize.plot_track_zones],\n            `aggregate` and `metric` are required.\n        - segment_zone_summary : Same as \"zone_summary\" but split aggregate per\n            segment [`plot_segment_zones`][geo_track_analyzer.visualize.plot_segment_zones]\n        - segment_box : Box plot of a metric (heartrate, power, cadence, speed,\n            elevation) per segment. Pass keyword args for [`plot_segments_on_map`][geo_track_analyzer.visualize.plot_segments_on_map]\n            `metric` is required.\n        - segment_summary : Visualize a aggregate (total_time, total_distance,\n            avg_speed, max_speed) per segment. Pass keyword args for [`plot_segment_summary`][geo_track_analyzer.visualize.plot_segment_summary]\n            `aggregate` is required.\n    :param segment: Select a specific segment, multiple segments or all segmenets,\n        defaults to None\n    :param reduce_pp_intervals: Optionally pass a distance in m which is used to\n        reduce the points in a track, defaults to None\n    :param use_distance_segments: Ignore all segments in data and split full track\n        into segments with passed cummulated distance in meters. If passed, segment\n        arg must be None. Defaults to None.\n    :raises VisualizationSetupError: If the plot prequisites are not met\n\n    :return: Figure (plotly)\n    \"\"\"\n    from geo_track_analyzer.utils.track import generate_distance_segments\n\n    if use_distance_segments is not None and segment is not None:\n        raise VisualizationSetupError(\n            f\"use_distance_segments {use_distance_segments} cannot be passed with \"\n            f\"segment {segment}.\"\n        )\n\n    valid_kinds = [\n        \"profile\",\n        \"profile-slope\",\n        \"map-line\",\n        \"map-line-enhanced\",\n        \"map-segments\",\n        \"zone_summary\",\n        \"segment_zone_summary\",\n        \"segment_box\",\n        \"segment_summary\",\n    ]\n\n    require_elevation = [\"profile\", \"profile-slope\"]\n    connect_segment_full = [\"map-segments\"]\n    if kind not in valid_kinds:\n        raise VisualizationSetupError(\n            f\"Kind {kind} is not valid. Pass on of {','.join(valid_kinds)}\"\n        )\n\n    if kind in [\"zone_summary\", \"segment_zone_summary\"] and not all(\n        key in kwargs.keys() for key in [\"metric\", \"aggregate\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** and **aggregate** need to be passed\"\n        )\n    if kind in [\"segment_box\"] and not all(\n        key in kwargs.keys() for key in [\"metric\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** needs to be passed\"\n        )\n    if kind in [\"segment_summary\"] and not all(\n        key in kwargs.keys() for key in [\"aggregate\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** needs to be passed\"\n        )\n\n    if segment is None:\n        from geo_track_analyzer.utils.track import extract_track_data_for_plot\n\n        data = extract_track_data_for_plot(\n            track=self,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n            connect_segments=\"full\" if kind in connect_segment_full else \"forward\",\n        )\n    elif isinstance(segment, int):\n        from geo_track_analyzer.utils.track import extract_segment_data_for_plot\n\n        data = extract_segment_data_for_plot(\n            track=self,\n            segment=segment,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n        )\n    else:\n        from geo_track_analyzer.utils.track import (\n            extract_multiple_segment_data_for_plot,\n        )\n\n        data = extract_multiple_segment_data_for_plot(\n            track=self,\n            segments=segment,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n        )\n\n    if use_distance_segments is not None:\n        data = generate_distance_segments(data, use_distance_segments)\n\n    fig: Figure\n    if kind == \"profile\":\n        fig = plot_track_2d(data=data, **kwargs)\n    elif kind == \"profile-slope\":\n        fig = plot_track_with_slope(data=data, **kwargs)\n    elif kind == \"map-line\":\n        fig = plot_track_line_on_map(data=data, **kwargs)\n    elif kind == \"map-line-enhanced\":\n        fig = plot_track_enriched_on_map(data=data, **kwargs)\n    elif kind == \"map-segments\":\n        fig = plot_segments_on_map(data=data, **kwargs)\n    elif kind == \"zone_summary\":\n        fig = plot_track_zones(data=data, **kwargs)\n    elif kind == \"segment_zone_summary\":\n        fig = plot_segment_zones(data=data, **kwargs)\n    elif kind == \"segment_summary\":\n        fig = plot_segment_summary(data=data, **kwargs)\n    elif kind == \"segment_box\":\n        fig = plot_segment_box_summary(data=data, **kwargs)\n\n    return fig\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.FITTrack.split","title":"<code>split(coords, distance_threshold=20)</code>","text":"<p>Split the track at the passed coordinates. The distance_threshold parameter defines the maximum distance between the passed coordingates and the closest point in the track.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>tuple[float, float]</code> <p>Latitude, Longitude point at which the split should be made</p> required <code>distance_threshold</code> <code>float</code> <p>Maximum distance between coords and closest point, defaults to 20</p> <code>20</code> <p>Raises:</p> Type Description <code>TrackTransformationError</code> <p>If distance exceeds threshold</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def split(\n    self, coords: tuple[float, float], distance_threshold: float = 20\n) -&gt; None:\n    \"\"\"\n    Split the track at the passed coordinates. The distance_threshold parameter\n    defines the maximum distance between the passed coordingates and the closest\n    point in the track.\n\n    :param coords: Latitude, Longitude point at which the split should be made\n    :param distance_threshold: Maximum distance between coords and closest point,\n        defaults to 20\n\n    :raises TrackTransformationError: If distance exceeds threshold\n    \"\"\"\n    lat, long = coords\n    point_distance = get_point_distance(\n        self.track, None, latitude=lat, longitude=long\n    )\n\n    if point_distance.distance &gt; distance_threshold:\n        raise TrackTransformationError(\n            f\"Closes point in track has distance {point_distance.distance:.2f}m \"\n            \"from passed coordingates\"\n        )\n    # Split the segment. The closest point should be the first\n    # point of the second segment\n    pre_segment, post_segment = self.track.segments[\n        point_distance.segment_idx\n    ].split(point_distance.segment_point_idx - 1)\n\n    self.track.segments[point_distance.segment_idx] = pre_segment\n    self.track.segments.insert(point_distance.segment_idx + 1, post_segment)\n\n    self._processed_segment_data = {}\n    self._processed_track_data = {}\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack","title":"<code>ByteTrack(bytefile, n_track=0, stopped_speed_threshold=1, max_speed_percentile=95, heartrate_zones=None, power_zones=None, cadence_zones=None)</code>","text":"<p>             Bases: <code>Track</code></p> <p>Track that should be initialized from a byte stream</p> <p>Initialize a Track object from a gpx file</p> <p>Parameters:</p> Name Type Description Default <code>bytefile</code> <code>bytes</code> <p>Bytestring of a gpx file</p> required <code>n_track</code> <code>int</code> <p>Index of track in the gpx file, defaults to 0</p> <code>0</code> <code>stopped_speed_threshold</code> <code>float</code> <p>Minium speed required for a point to be count as moving, defaults to 1</p> <code>1</code> <code>max_speed_percentile</code> <code>int</code> <p>Points with speed outside of the percentile are not counted when analyzing the track, defaults to 95</p> <code>95</code> <code>heartrate_zones</code> <code>None | Zones</code> <p>Optional heartrate Zones, defaults to None</p> <code>None</code> <code>power_zones</code> <code>None | Zones</code> <p>Optional power Zones, defaults to None</p> <code>None</code> <code>cadence_zones</code> <code>None | Zones</code> <p>Optional cadence Zones, defaults to None</p> <code>None</code> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def __init__(\n    self,\n    bytefile: bytes,\n    n_track: int = 0,\n    stopped_speed_threshold: float = 1,\n    max_speed_percentile: int = 95,\n    heartrate_zones: None | Zones = None,\n    power_zones: None | Zones = None,\n    cadence_zones: None | Zones = None,\n) -&gt; None:\n    \"\"\"Initialize a Track object from a gpx file\n\n    :param bytefile: Bytestring of a gpx file\n    :param n_track: Index of track in the gpx file, defaults to 0\n    :param stopped_speed_threshold: Minium speed required for a point to be count\n        as moving, defaults to 1\n    :param max_speed_percentile: Points with speed outside of the percentile are not\n        counted when analyzing the track, defaults to 95\n    :param heartrate_zones: Optional heartrate Zones, defaults to None\n    :param power_zones: Optional power Zones, defaults to None\n    :param cadence_zones: Optional cadence Zones, defaults to None\n    \"\"\"\n    super().__init__(\n        stopped_speed_threshold=stopped_speed_threshold,\n        max_speed_percentile=max_speed_percentile,\n        heartrate_zones=heartrate_zones,\n        power_zones=power_zones,\n        cadence_zones=cadence_zones,\n    )\n\n    gpx = gpxpy.parse(bytefile)\n\n    self._track = gpx.tracks[n_track]\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.add_segmeent","title":"<code>add_segmeent(segment)</code>","text":"<p>Add a new segment ot the track</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>GPXTrackSegment</code> <p>GPXTracksegment to be added</p> required Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def add_segmeent(self, segment: GPXTrackSegment) -&gt; None:\n    \"\"\"Add a new segment ot the track\n\n    :param segment: GPXTracksegment to be added\n    \"\"\"\n    self.track.segments.append(segment)\n    logger.info(\"Added segment with postition: %s\", len(self.track.segments))\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.find_overlap_with_segment","title":"<code>find_overlap_with_segment(n_segment, match_track, match_track_segment=0, width=50, overlap_threshold=0.75, max_queue_normalize=5, merge_subsegments=5, extensions_interpolation='copy-forward')</code>","text":"<p>Find overlap of a segment of the track with a segment in another track.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Segment in the track that sould be used as base for the comparison</p> required <code>match_track</code> <code>Track</code> <p>Track object containing the segment to be matched</p> required <code>match_track_segment</code> <code>int</code> <p>Segment on the passed track that should be matched to the segment in this track, defaults to 0</p> <code>0</code> <code>width</code> <code>float</code> <p>Width (in meters) of the grid that will be filled to estimate the overalp , defaults to 50</p> <code>50</code> <code>overlap_threshold</code> <code>float</code> <p>Minimum overlap (as fracrtion) required to return the overlap data, defaults to 0.75</p> <code>0.75</code> <code>max_queue_normalize</code> <code>int</code> <p>Minimum number of successive points in the segment between two points falling into same plate bin, defaults to 5</p> <code>5</code> <code>merge_subsegments</code> <code>int</code> <p>Number of points between sub segments allowed for merging the segments, defaults to 5</p> <code>5</code> <code>extensions_interpolation</code> <code>Literal['copy-forward', 'meet-center', 'linear']</code> <p>How should the extenstion (if present) be defined in the interpolated points, defaults to copy-forward</p> <code>'copy-forward'</code> <p>Returns:</p> Type Description <code>Sequence[tuple[Track, float, bool]]</code> <p>Tuple containing a Track with the overlapping points, the overlap in percent, and the direction of the overlap</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def find_overlap_with_segment(\n    self,\n    n_segment: int,\n    match_track: Track,\n    match_track_segment: int = 0,\n    width: float = 50,\n    overlap_threshold: float = 0.75,\n    max_queue_normalize: int = 5,\n    merge_subsegments: int = 5,\n    extensions_interpolation: Literal[\n        \"copy-forward\", \"meet-center\", \"linear\"\n    ] = \"copy-forward\",\n) -&gt; Sequence[tuple[Track, float, bool]]:\n    \"\"\"Find overlap of a segment of the track with a segment in another track.\n\n    :param n_segment: Segment in the track that sould be used as base for the\n        comparison\n    :param match_track: Track object containing the segment to be matched\n    :param match_track_segment: Segment on the passed track that should be matched\n        to the segment in this track, defaults to 0\n    :param width: Width (in meters) of the grid that will be filled to estimate\n        the overalp , defaults to 50\n    :param overlap_threshold: Minimum overlap (as fracrtion) required to return the\n        overlap data, defaults to 0.75\n    :param max_queue_normalize: Minimum number of successive points in the segment\n        between two points falling into same plate bin, defaults to 5\n    :param merge_subsegments: Number of points between sub segments allowed\n        for merging the segments, defaults to 5\n    :param extensions_interpolation: How should the extenstion (if present) be\n        defined in the interpolated points, defaults to copy-forward\n\n    :return: Tuple containing a Track with the overlapping points, the overlap in\n        percent, and the direction of the overlap\n    \"\"\"\n    max_distance_self = self.get_max_pp_distance_in_segment(n_segment)\n\n    segment_self = self.track.segments[n_segment]\n    if max_distance_self &gt; width:\n        segment_self = interpolate_segment(\n            segment_self, width / 2, copy_extensions=extensions_interpolation\n        )\n\n    max_distance_match = match_track.get_max_pp_distance_in_segment(\n        match_track_segment\n    )\n    segment_match = match_track.track.segments[match_track_segment]\n    if max_distance_match &gt; width:\n        segment_match = interpolate_segment(\n            segment_match, width / 2, copy_extensions=extensions_interpolation\n        )\n\n    logger.info(\"Looking for overlapping segments\")\n    segment_overlaps = get_segment_overlap(\n        segment_self,\n        segment_match,\n        width,\n        max_queue_normalize,\n        merge_subsegments,\n        overlap_threshold,\n    )\n\n    matched_tracks: list[tuple[Track, float, bool]] = []\n    for overlap in segment_overlaps:\n        logger.info(\"Found: %s\", overlap)\n        matched_segment = GPXTrackSegment()\n        # TODO: Might need to go up to overlap.end_idx + 1?\n        matched_segment.points = self.track.segments[n_segment].points[\n            overlap.start_idx : overlap.end_idx\n        ]\n        matched_tracks.append(\n            (\n                SegmentTrack(\n                    matched_segment,\n                    stopped_speed_threshold=self.stopped_speed_threshold,\n                    max_speed_percentile=self.max_speed_percentile,\n                ),\n                overlap.overlap,\n                overlap.inverse,\n            )\n        )\n    return matched_tracks\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_avg_pp_distance","title":"<code>get_avg_pp_distance(threshold=10)</code>","text":"<p>Get average distance between points in the track.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the average, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Average distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_avg_pp_distance(self, threshold: float = 10) -&gt; float:\n    \"\"\"\n    Get average distance between points in the track.\n\n    :param threshold: Minimum distance between points required to  be used for the\n        average, defaults to 10\n\n    :return: Average distance\n    \"\"\"\n    return self._get_aggregated_pp_distance(\"average\", threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_avg_pp_distance_in_segment","title":"<code>get_avg_pp_distance_in_segment(n_segment=0, threshold=10)</code>","text":"<p>Get average distance between points in the segment with index n_segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement to process, defaults to 0</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the average, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Average distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_avg_pp_distance_in_segment(\n    self, n_segment: int = 0, threshold: float = 10\n) -&gt; float:\n    \"\"\"\n    Get average distance between points in the segment with index n_segment.\n\n    :param n_segment: Index of the segement to process, defaults to 0\n    :param threshold: Minimum distance between points required to  be used for the\n        average, defaults to 10\n\n    :return: Average distance\n    \"\"\"\n    return self._get_aggregated_pp_distance_in_segment(\n        \"average\", n_segment, threshold\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_closest_point","title":"<code>get_closest_point(n_segment, latitude, longitude)</code>","text":"<p>Get closest point in a segment or track to the passed latitude and longitude corrdinate</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>None | int</code> <p>Index of the segment. If None is passed the whole track is considered</p> required <code>latitude</code> <code>float</code> <p>Latitude to check</p> required <code>longitude</code> <code>float</code> <p>Longitude to check</p> required <p>Returns:</p> Type Description <code>PointDistance</code> <p>Tuple containg the point as GPXTrackPoint, the distance from the passed coordinates and the index in the segment</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_closest_point(\n    self, n_segment: None | int, latitude: float, longitude: float\n) -&gt; PointDistance:\n    \"\"\"\n    Get closest point in a segment or track to the passed latitude and longitude\n    corrdinate\n\n    :param n_segment: Index of the segment. If None is passed the whole track is\n        considered\n    :param latitude: Latitude to check\n    :param longitude: Longitude to check\n\n    :return: Tuple containg the point as GPXTrackPoint, the distance from\n        the passed coordinates and the index in the segment\n    \"\"\"\n    return get_point_distance(self.track, n_segment, latitude, longitude)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_max_pp_distance","title":"<code>get_max_pp_distance(threshold=10)</code>","text":"<p>Get maximum distance between points in the track.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the maximum, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Maximum distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_max_pp_distance(self, threshold: float = 10) -&gt; float:\n    \"\"\"\n    Get maximum distance between points in the track.\n\n    :param threshold: Minimum distance between points required to  be used for the\n        maximum, defaults to 10\n\n    :return: Maximum distance\n    \"\"\"\n    return self._get_aggregated_pp_distance(\"max\", threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_max_pp_distance_in_segment","title":"<code>get_max_pp_distance_in_segment(n_segment=0, threshold=10)</code>","text":"<p>Get maximum distance between points in the segment with index n_segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement to process, defaults to 0</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the maximum, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Maximum distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_max_pp_distance_in_segment(\n    self, n_segment: int = 0, threshold: float = 10\n) -&gt; float:\n    \"\"\"\n    Get maximum distance between points in the segment with index n_segment.\n\n    :param n_segment: Index of the segement to process, defaults to 0\n    :param threshold: Minimum distance between points required to  be used for the\n        maximum, defaults to 10\n\n    :return: Maximum distance\n    \"\"\"\n    return self._get_aggregated_pp_distance_in_segment(\"max\", n_segment, threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_point_data_in_segmnet","title":"<code>get_point_data_in_segmnet(n_segment=0)</code>","text":"<p>Get raw coordinates (latitude, longitude), times and elevations for the segement with the passed index.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[list[tuple[float, float]], None | list[float], None | list[datetime]]</code> <p>tuple with coordinates (latitude, longitude), times and elevations</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_point_data_in_segmnet(\n    self, n_segment: int = 0\n) -&gt; tuple[list[tuple[float, float]], None | list[float], None | list[datetime]]:\n    \"\"\"Get raw coordinates (latitude, longitude), times and elevations for the\n    segement with the passed index.\n\n    :param n_segment: Index of the segement, defaults to 0\n\n    :return: tuple with coordinates (latitude, longitude), times and elevations\n    \"\"\"\n    coords = []\n    elevations = []\n    times = []\n\n    for point in self.track.segments[n_segment].points:\n        coords.append((point.latitude, point.longitude))\n        if point.elevation is not None:\n            elevations.append(point.elevation)\n        if point.time is not None:\n            times.append(point.time)\n\n    if not elevations:\n        elevations = None  # type: ignore\n    elif len(coords) != len(elevations):\n        raise TrackTransformationError(\n            \"Elevation is not set for all points. This is not supported\"\n        )\n    if not times:\n        times = None  # type: ignore\n    elif len(coords) != len(times):\n        raise TrackTransformationError(\n            \"Elevation is not set for all points. This is not supported\"\n        )\n\n    return coords, elevations, times\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_segment_data","title":"<code>get_segment_data(n_segment=0)</code>","text":"<p>Get processed data for the segmeent with passed index as DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with segmenet data</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_segment_data(self, n_segment: int = 0) -&gt; pd.DataFrame:\n    \"\"\"Get processed data for the segmeent with passed index as DataFrame\n\n    :param n_segment: Index of the segement, defaults to 0\n\n    :return: DataFrame with segmenet data\n    \"\"\"\n    _, _, _, _, data = self._get_processed_segment_data(n_segment)\n\n    return data\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_segment_overview","title":"<code>get_segment_overview(n_segment=0)</code>","text":"<p>Get overall metrics for a segment</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segment the overview should be generated for, default to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>SegmentOverview</code> <p>A SegmentOverview object containing the metrics moving time and distance, total time and distance, maximum and average speed and elevation and cummulated uphill, downholl elevation</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_segment_overview(self, n_segment: int = 0) -&gt; SegmentOverview:\n    \"\"\"\n    Get overall metrics for a segment\n\n    :param n_segment: Index of the segment the overview should be generated for,\n        default to 0\n\n    :returns: A SegmentOverview object containing the metrics moving time and\n        distance, total time and distance, maximum and average speed and elevation\n        and cummulated uphill, downholl elevation\n    \"\"\"\n    (\n        time,\n        distance,\n        stopped_time,\n        stopped_distance,\n        data,\n    ) = self._get_processed_segment_data(n_segment)\n\n    max_speed = None\n    avg_speed = None\n\n    if self.track.segments[n_segment].has_times():\n        max_speed = data.speed[data.in_speed_percentile].max()\n        avg_speed = data.speed[data.in_speed_percentile].mean()\n\n    return self._create_segment_overview(\n        time=time,\n        distance=distance,\n        stopped_time=stopped_time,\n        stopped_distance=stopped_distance,\n        max_speed=max_speed,\n        avg_speed=avg_speed,\n        data=data,\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_track_data","title":"<code>get_track_data(connect_segments='forward')</code>","text":"<p>Get processed data for the track as DataFrame. Segment are indicated via the segment column.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with track data</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_track_data(\n    self, connect_segments: Literal[\"full\", \"forward\"] = \"forward\"\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Get processed data for the track as DataFrame. Segment are indicated\n    via the segment column.\n\n    :return: DataFrame with track data\n    \"\"\"\n    track_data: None | pd.DataFrame = None\n\n    _, _, _, _, track_data = self._get_processed_track_data(\n        connect_segments=connect_segments\n    )\n\n    return track_data\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_track_overview","title":"<code>get_track_overview(connect_segments='forward')</code>","text":"<p>Get overall metrics for the track. Equivalent to the sum of all segments</p> <p>Returns:</p> Type Description <code>SegmentOverview</code> <p>A SegmentOverview object containing the metrics</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_track_overview(\n    self, connect_segments: Literal[\"full\", \"forward\"] = \"forward\"\n) -&gt; SegmentOverview:\n    \"\"\"\n    Get overall metrics for the track. Equivalent to the sum of all segments\n\n    :return: A SegmentOverview object containing the metrics\n    \"\"\"\n    (\n        track_time,\n        track_distance,\n        track_stopped_time,\n        track_stopped_distance,\n        track_data,\n    ) = self._get_processed_track_data(connect_segments=connect_segments)\n\n    track_max_speed = None\n    track_avg_speed = None\n\n    if all(seg.has_times() for seg in self.track.segments):\n        track_max_speed = track_data.speed[track_data.in_speed_percentile].max()\n        track_avg_speed = track_data.speed[track_data.in_speed_percentile].mean()\n\n    return self._create_segment_overview(\n        time=track_time,\n        distance=track_distance,\n        stopped_time=track_stopped_time,\n        stopped_distance=track_stopped_distance,\n        max_speed=track_max_speed,\n        avg_speed=track_avg_speed,\n        data=track_data,  # type: ignore\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.get_xml","title":"<code>get_xml(name=None, email=None)</code>","text":"<p>Get track as .gpx file data</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>None | str</code> <p>Optional author name to be added to gpx file, defaults to None</p> <code>None</code> <code>email</code> <code>None | str</code> <p>Optional auther e-mail address to be added to the gpx file, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Content of a gpx file</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_xml(self, name: None | str = None, email: None | str = None) -&gt; str:\n    \"\"\"Get track as .gpx file data\n\n    :param name: Optional author name to be added to gpx file, defaults to None\n    :param email: Optional auther e-mail address to be added to the gpx file,\n        defaults to None\n\n    :return: Content of a gpx file\n    \"\"\"\n    gpx = GPX()\n\n    gpx.tracks = [self.track]\n    gpx.author_name = name\n    gpx.author_email = email\n\n    return gpx.to_xml()\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.interpolate_points_in_segment","title":"<code>interpolate_points_in_segment(spacing, n_segment=0, copy_extensions='copy-forward')</code>","text":"<p>Add additdion points to a segment by interpolating along the direct line between each point pair according to the passed spacing parameter. If present, elevation and time will be linearly interpolated. Extensions (Heartrate, Cadence, Power) will be interpolated according to value of copy_extensions. Optionas are:</p> <ul> <li>copy the value from the start point of the interpolation (copy-forward)</li> <li>Use value of start point for first half and last point for second half   (meet-center)</li> <li>Linear interpolation (linear)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>spacing</code> <code>float</code> <p>Minimum distance between points added by the interpolation</p> required <code>n_segment</code> <code>int</code> <p>segment in the track to use, defaults to 0</p> <code>0</code> <code>copy_extensions</code> <code>Literal['copy-forward', 'meet-center', 'linear']</code> <p>How should the extenstion (if present) be defined in the interpolated points.</p> <code>'copy-forward'</code> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def interpolate_points_in_segment(\n    self,\n    spacing: float,\n    n_segment: int = 0,\n    copy_extensions: Literal[\n        \"copy-forward\", \"meet-center\", \"linear\"\n    ] = \"copy-forward\",\n) -&gt; None:\n    \"\"\"\n    Add additdion points to a segment by interpolating along the direct line\n    between each point pair according to the passed spacing parameter. If present,\n    elevation and time will be linearly interpolated. Extensions (Heartrate,\n    Cadence, Power) will be interpolated according to value of copy_extensions.\n    Optionas are:\n\n    - copy the value from the start point of the interpolation (copy-forward)\n    - Use value of start point for first half and last point for second half\n      (meet-center)\n    - Linear interpolation (linear)\n\n\n    :param spacing: Minimum distance between points added by the interpolation\n    :param n_segment: segment in the track to use, defaults to 0\n    :param copy_extensions: How should the extenstion (if present) be defined in the\n        interpolated points.\n    \"\"\"\n    self.track.segments[n_segment] = interpolate_segment(\n        self.track.segments[n_segment], spacing, copy_extensions=copy_extensions\n    )\n\n    # Reset saved processed data\n    for key in self._processed_track_data.keys():\n        self._processed_track_data.pop(key)\n    if n_segment in self._processed_segment_data:\n        logger.debug(\n            \"Deleting saved processed segment data for segment %s\", n_segment\n        )\n        self._processed_segment_data.pop(n_segment)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.plot","title":"<code>plot(kind, *, segment=None, reduce_pp_intervals=None, use_distance_segments=None, **kwargs)</code>","text":"<p>Visualize the full track or a single segment.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Literal['profile', 'profile-slope', 'map-line', 'map-line-enhanced', 'map-segments', 'zone_summary', 'segment_zone_summary', 'segment_box', 'segment_summary']</code> <p>Kind of plot to be generated  - profile: Elevation profile of the track. May be enhanced with additional information like Velocity, Heartrate, Cadence, and Power. Pass keyword args for <code>plot_track_2d</code> - profile-slope: Elevation profile with slopes between points. Use the reduce_pp_intervals argument to reduce the number of slope intervals. Pass keyword args for <code>plot_track_with_slope</code> - map-line: Visualize coordinates on the map. Pass keyword args for <code>plot_track_line_on_map</code> - map-line-enhanced: Visualize coordinates on the map. Enhance with additional information like Elevation, Velocity, Heartrate, Cadence, and Power. Pass keyword args for <code>plot_track_enriched_on_map</code> - map-segments: Visualize coordinates on the map split into segments. Pass keyword args for <code>plot_segments_on_map</code> - zone_summary : Visualize an aggregate (time, distance, speed) value for a metric (heartrate, power, cadence) with defined zones. Pass keyword args for <code>plot_track_zones</code>, <code>aggregate</code> and <code>metric</code> are required. - segment_zone_summary : Same as \"zone_summary\" but split aggregate per segment <code>plot_segment_zones</code> - segment_box : Box plot of a metric (heartrate, power, cadence, speed, elevation) per segment. Pass keyword args for <code>plot_segments_on_map</code> <code>metric</code> is required. - segment_summary : Visualize a aggregate (total_time, total_distance, avg_speed, max_speed) per segment. Pass keyword args for <code>plot_segment_summary</code> <code>aggregate</code> is required.</p> required <code>segment</code> <code>None | int | list[int]</code> <p>Select a specific segment, multiple segments or all segmenets, defaults to None</p> <code>None</code> <code>reduce_pp_intervals</code> <code>None | int</code> <p>Optionally pass a distance in m which is used to reduce the points in a track, defaults to None</p> <code>None</code> <code>use_distance_segments</code> <code>None | float</code> <p>Ignore all segments in data and split full track into segments with passed cummulated distance in meters. If passed, segment arg must be None. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Figure (plotly)</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>If the plot prequisites are not met</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def plot(\n    self,\n    kind: Literal[\n        \"profile\",\n        \"profile-slope\",\n        \"map-line\",\n        \"map-line-enhanced\",\n        \"map-segments\",\n        \"zone_summary\",\n        \"segment_zone_summary\",\n        \"segment_box\",\n        \"segment_summary\",\n    ],\n    *,\n    segment: None | int | list[int] = None,\n    reduce_pp_intervals: None | int = None,\n    use_distance_segments: None | float = None,\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"\n    Visualize the full track or a single segment.\n\n    :param kind: Kind of plot to be generated\n\n        - profile: Elevation profile of the track. May be enhanced with additional\n          information like Velocity, Heartrate, Cadence, and Power. Pass keyword\n          args for [`plot_track_2d`][geo_track_analyzer.visualize.plot_track_2d]\n        - profile-slope: Elevation profile with slopes between points. Use the\n          reduce_pp_intervals argument to reduce the number of slope intervals.\n          Pass keyword args for\n          [`plot_track_with_slope`][geo_track_analyzer.visualize.plot_track_with_slope]\n        - map-line: Visualize coordinates on the map. Pass keyword args for\n          [`plot_track_line_on_map`][geo_track_analyzer.visualize.plot_track_line_on_map]\n        - map-line-enhanced: Visualize coordinates on the map. Enhance with\n          additional information like Elevation, Velocity, Heartrate, Cadence, and\n          Power. Pass keyword args for [`plot_track_enriched_on_map`][geo_track_analyzer.visualize.plot_track_enriched_on_map]\n        - map-segments: Visualize coordinates on the map split into segments.\n          Pass keyword args for\n          [`plot_segments_on_map`][geo_track_analyzer.visualize.plot_segments_on_map]\n        - zone_summary : Visualize an aggregate (time, distance, speed) value for a\n            metric (heartrate, power, cadence) with defined zones. Pass keyword args\n            for [`plot_track_zones`][geo_track_analyzer.visualize.plot_track_zones],\n            `aggregate` and `metric` are required.\n        - segment_zone_summary : Same as \"zone_summary\" but split aggregate per\n            segment [`plot_segment_zones`][geo_track_analyzer.visualize.plot_segment_zones]\n        - segment_box : Box plot of a metric (heartrate, power, cadence, speed,\n            elevation) per segment. Pass keyword args for [`plot_segments_on_map`][geo_track_analyzer.visualize.plot_segments_on_map]\n            `metric` is required.\n        - segment_summary : Visualize a aggregate (total_time, total_distance,\n            avg_speed, max_speed) per segment. Pass keyword args for [`plot_segment_summary`][geo_track_analyzer.visualize.plot_segment_summary]\n            `aggregate` is required.\n    :param segment: Select a specific segment, multiple segments or all segmenets,\n        defaults to None\n    :param reduce_pp_intervals: Optionally pass a distance in m which is used to\n        reduce the points in a track, defaults to None\n    :param use_distance_segments: Ignore all segments in data and split full track\n        into segments with passed cummulated distance in meters. If passed, segment\n        arg must be None. Defaults to None.\n    :raises VisualizationSetupError: If the plot prequisites are not met\n\n    :return: Figure (plotly)\n    \"\"\"\n    from geo_track_analyzer.utils.track import generate_distance_segments\n\n    if use_distance_segments is not None and segment is not None:\n        raise VisualizationSetupError(\n            f\"use_distance_segments {use_distance_segments} cannot be passed with \"\n            f\"segment {segment}.\"\n        )\n\n    valid_kinds = [\n        \"profile\",\n        \"profile-slope\",\n        \"map-line\",\n        \"map-line-enhanced\",\n        \"map-segments\",\n        \"zone_summary\",\n        \"segment_zone_summary\",\n        \"segment_box\",\n        \"segment_summary\",\n    ]\n\n    require_elevation = [\"profile\", \"profile-slope\"]\n    connect_segment_full = [\"map-segments\"]\n    if kind not in valid_kinds:\n        raise VisualizationSetupError(\n            f\"Kind {kind} is not valid. Pass on of {','.join(valid_kinds)}\"\n        )\n\n    if kind in [\"zone_summary\", \"segment_zone_summary\"] and not all(\n        key in kwargs.keys() for key in [\"metric\", \"aggregate\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** and **aggregate** need to be passed\"\n        )\n    if kind in [\"segment_box\"] and not all(\n        key in kwargs.keys() for key in [\"metric\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** needs to be passed\"\n        )\n    if kind in [\"segment_summary\"] and not all(\n        key in kwargs.keys() for key in [\"aggregate\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** needs to be passed\"\n        )\n\n    if segment is None:\n        from geo_track_analyzer.utils.track import extract_track_data_for_plot\n\n        data = extract_track_data_for_plot(\n            track=self,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n            connect_segments=\"full\" if kind in connect_segment_full else \"forward\",\n        )\n    elif isinstance(segment, int):\n        from geo_track_analyzer.utils.track import extract_segment_data_for_plot\n\n        data = extract_segment_data_for_plot(\n            track=self,\n            segment=segment,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n        )\n    else:\n        from geo_track_analyzer.utils.track import (\n            extract_multiple_segment_data_for_plot,\n        )\n\n        data = extract_multiple_segment_data_for_plot(\n            track=self,\n            segments=segment,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n        )\n\n    if use_distance_segments is not None:\n        data = generate_distance_segments(data, use_distance_segments)\n\n    fig: Figure\n    if kind == \"profile\":\n        fig = plot_track_2d(data=data, **kwargs)\n    elif kind == \"profile-slope\":\n        fig = plot_track_with_slope(data=data, **kwargs)\n    elif kind == \"map-line\":\n        fig = plot_track_line_on_map(data=data, **kwargs)\n    elif kind == \"map-line-enhanced\":\n        fig = plot_track_enriched_on_map(data=data, **kwargs)\n    elif kind == \"map-segments\":\n        fig = plot_segments_on_map(data=data, **kwargs)\n    elif kind == \"zone_summary\":\n        fig = plot_track_zones(data=data, **kwargs)\n    elif kind == \"segment_zone_summary\":\n        fig = plot_segment_zones(data=data, **kwargs)\n    elif kind == \"segment_summary\":\n        fig = plot_segment_summary(data=data, **kwargs)\n    elif kind == \"segment_box\":\n        fig = plot_segment_box_summary(data=data, **kwargs)\n\n    return fig\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.ByteTrack.split","title":"<code>split(coords, distance_threshold=20)</code>","text":"<p>Split the track at the passed coordinates. The distance_threshold parameter defines the maximum distance between the passed coordingates and the closest point in the track.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>tuple[float, float]</code> <p>Latitude, Longitude point at which the split should be made</p> required <code>distance_threshold</code> <code>float</code> <p>Maximum distance between coords and closest point, defaults to 20</p> <code>20</code> <p>Raises:</p> Type Description <code>TrackTransformationError</code> <p>If distance exceeds threshold</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def split(\n    self, coords: tuple[float, float], distance_threshold: float = 20\n) -&gt; None:\n    \"\"\"\n    Split the track at the passed coordinates. The distance_threshold parameter\n    defines the maximum distance between the passed coordingates and the closest\n    point in the track.\n\n    :param coords: Latitude, Longitude point at which the split should be made\n    :param distance_threshold: Maximum distance between coords and closest point,\n        defaults to 20\n\n    :raises TrackTransformationError: If distance exceeds threshold\n    \"\"\"\n    lat, long = coords\n    point_distance = get_point_distance(\n        self.track, None, latitude=lat, longitude=long\n    )\n\n    if point_distance.distance &gt; distance_threshold:\n        raise TrackTransformationError(\n            f\"Closes point in track has distance {point_distance.distance:.2f}m \"\n            \"from passed coordingates\"\n        )\n    # Split the segment. The closest point should be the first\n    # point of the second segment\n    pre_segment, post_segment = self.track.segments[\n        point_distance.segment_idx\n    ].split(point_distance.segment_point_idx - 1)\n\n    self.track.segments[point_distance.segment_idx] = pre_segment\n    self.track.segments.insert(point_distance.segment_idx + 1, post_segment)\n\n    self._processed_segment_data = {}\n    self._processed_track_data = {}\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack","title":"<code>PyTrack(points, elevations, times, heartrate=None, cadence=None, power=None, stopped_speed_threshold=1, max_speed_percentile=95, heartrate_zones=None, power_zones=None, cadence_zones=None)</code>","text":"<p>             Bases: <code>Track</code></p> <p>Track that should be initialized from python objects</p> <p>A geospacial data track initialized from python objects</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple[float, float]]</code> <p>List of Latitude/Longitude tuples</p> required <code>elevations</code> <code>None | list[float]</code> <p>Optional list of elevation for each point</p> required <code>times</code> <code>None | list[datetime]</code> <p>Optional list of times for each point</p> required <code>heartrate</code> <code>None | list[int]</code> <p>Optional list of heartrate values for each point</p> <code>None</code> <code>cadence</code> <code>None | list[int]</code> <p>Optional list of cadence values for each point</p> <code>None</code> <code>power</code> <code>None | list[int]</code> <p>Optional list of power values for each point</p> <code>None</code> <code>stopped_speed_threshold</code> <code>float</code> <p>Minium speed required for a point to be count as moving, defaults to 1</p> <code>1</code> <code>max_speed_percentile</code> <code>int</code> <p>Points with speed outside of the percentile are not counted when analyzing the track, defaults to 95</p> <code>95</code> <code>heartrate_zones</code> <code>None | Zones</code> <p>Optional heartrate Zones, defaults to None</p> <code>None</code> <code>power_zones</code> <code>None | Zones</code> <p>Optional power Zones, defaults to None</p> <code>None</code> <code>cadence_zones</code> <code>None | Zones</code> <p>Optional cadence Zones, defaults to None</p> <code>None</code> <p>Raises:</p> Type Description <code>TrackInitializationError</code> <p>Raised if number of elevation, time, heatrate, or cadence values do not match passed points</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def __init__(\n    self,\n    points: list[tuple[float, float]],\n    elevations: None | list[float],\n    times: None | list[datetime],\n    heartrate: None | list[int] = None,\n    cadence: None | list[int] = None,\n    power: None | list[int] = None,\n    stopped_speed_threshold: float = 1,\n    max_speed_percentile: int = 95,\n    heartrate_zones: None | Zones = None,\n    power_zones: None | Zones = None,\n    cadence_zones: None | Zones = None,\n) -&gt; None:\n    \"\"\"A geospacial data track initialized from python objects\n\n    :param points: List of Latitude/Longitude tuples\n    :param elevations: Optional list of elevation for each point\n    :param times: Optional list of times for each point\n    :param heartrate: Optional list of heartrate values for each point\n    :param cadence: Optional list of cadence values for each point\n    :param power: Optional list of power values for each point\n    :param stopped_speed_threshold: Minium speed required for a point to be count\n        as moving, defaults to 1\n    :param max_speed_percentile: Points with speed outside of the percentile are not\n        counted when analyzing the track, defaults to 95\n    :param heartrate_zones: Optional heartrate Zones, defaults to None\n    :param power_zones: Optional power Zones, defaults to None\n    :param cadence_zones: Optional cadence Zones, defaults to None\n    :raises TrackInitializationError: Raised if number of elevation, time, heatrate,\n        or cadence values do not match passed points\n    \"\"\"\n    super().__init__(\n        stopped_speed_threshold=stopped_speed_threshold,\n        max_speed_percentile=max_speed_percentile,\n        heartrate_zones=heartrate_zones,\n        power_zones=power_zones,\n        cadence_zones=cadence_zones,\n    )\n\n    gpx = GPX()\n\n    gpx_track = GPXTrack()\n    gpx.tracks.append(gpx_track)\n\n    gpx_segment = self._create_segmeent(\n        points=points,\n        elevations=elevations,\n        times=times,\n        heartrate=heartrate,\n        cadence=cadence,\n        power=power,\n    )\n\n    gpx_track.segments.append(gpx_segment)\n\n    self._track = gpx.tracks[0]\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.find_overlap_with_segment","title":"<code>find_overlap_with_segment(n_segment, match_track, match_track_segment=0, width=50, overlap_threshold=0.75, max_queue_normalize=5, merge_subsegments=5, extensions_interpolation='copy-forward')</code>","text":"<p>Find overlap of a segment of the track with a segment in another track.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Segment in the track that sould be used as base for the comparison</p> required <code>match_track</code> <code>Track</code> <p>Track object containing the segment to be matched</p> required <code>match_track_segment</code> <code>int</code> <p>Segment on the passed track that should be matched to the segment in this track, defaults to 0</p> <code>0</code> <code>width</code> <code>float</code> <p>Width (in meters) of the grid that will be filled to estimate the overalp , defaults to 50</p> <code>50</code> <code>overlap_threshold</code> <code>float</code> <p>Minimum overlap (as fracrtion) required to return the overlap data, defaults to 0.75</p> <code>0.75</code> <code>max_queue_normalize</code> <code>int</code> <p>Minimum number of successive points in the segment between two points falling into same plate bin, defaults to 5</p> <code>5</code> <code>merge_subsegments</code> <code>int</code> <p>Number of points between sub segments allowed for merging the segments, defaults to 5</p> <code>5</code> <code>extensions_interpolation</code> <code>Literal['copy-forward', 'meet-center', 'linear']</code> <p>How should the extenstion (if present) be defined in the interpolated points, defaults to copy-forward</p> <code>'copy-forward'</code> <p>Returns:</p> Type Description <code>Sequence[tuple[Track, float, bool]]</code> <p>Tuple containing a Track with the overlapping points, the overlap in percent, and the direction of the overlap</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def find_overlap_with_segment(\n    self,\n    n_segment: int,\n    match_track: Track,\n    match_track_segment: int = 0,\n    width: float = 50,\n    overlap_threshold: float = 0.75,\n    max_queue_normalize: int = 5,\n    merge_subsegments: int = 5,\n    extensions_interpolation: Literal[\n        \"copy-forward\", \"meet-center\", \"linear\"\n    ] = \"copy-forward\",\n) -&gt; Sequence[tuple[Track, float, bool]]:\n    \"\"\"Find overlap of a segment of the track with a segment in another track.\n\n    :param n_segment: Segment in the track that sould be used as base for the\n        comparison\n    :param match_track: Track object containing the segment to be matched\n    :param match_track_segment: Segment on the passed track that should be matched\n        to the segment in this track, defaults to 0\n    :param width: Width (in meters) of the grid that will be filled to estimate\n        the overalp , defaults to 50\n    :param overlap_threshold: Minimum overlap (as fracrtion) required to return the\n        overlap data, defaults to 0.75\n    :param max_queue_normalize: Minimum number of successive points in the segment\n        between two points falling into same plate bin, defaults to 5\n    :param merge_subsegments: Number of points between sub segments allowed\n        for merging the segments, defaults to 5\n    :param extensions_interpolation: How should the extenstion (if present) be\n        defined in the interpolated points, defaults to copy-forward\n\n    :return: Tuple containing a Track with the overlapping points, the overlap in\n        percent, and the direction of the overlap\n    \"\"\"\n    max_distance_self = self.get_max_pp_distance_in_segment(n_segment)\n\n    segment_self = self.track.segments[n_segment]\n    if max_distance_self &gt; width:\n        segment_self = interpolate_segment(\n            segment_self, width / 2, copy_extensions=extensions_interpolation\n        )\n\n    max_distance_match = match_track.get_max_pp_distance_in_segment(\n        match_track_segment\n    )\n    segment_match = match_track.track.segments[match_track_segment]\n    if max_distance_match &gt; width:\n        segment_match = interpolate_segment(\n            segment_match, width / 2, copy_extensions=extensions_interpolation\n        )\n\n    logger.info(\"Looking for overlapping segments\")\n    segment_overlaps = get_segment_overlap(\n        segment_self,\n        segment_match,\n        width,\n        max_queue_normalize,\n        merge_subsegments,\n        overlap_threshold,\n    )\n\n    matched_tracks: list[tuple[Track, float, bool]] = []\n    for overlap in segment_overlaps:\n        logger.info(\"Found: %s\", overlap)\n        matched_segment = GPXTrackSegment()\n        # TODO: Might need to go up to overlap.end_idx + 1?\n        matched_segment.points = self.track.segments[n_segment].points[\n            overlap.start_idx : overlap.end_idx\n        ]\n        matched_tracks.append(\n            (\n                SegmentTrack(\n                    matched_segment,\n                    stopped_speed_threshold=self.stopped_speed_threshold,\n                    max_speed_percentile=self.max_speed_percentile,\n                ),\n                overlap.overlap,\n                overlap.inverse,\n            )\n        )\n    return matched_tracks\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_avg_pp_distance","title":"<code>get_avg_pp_distance(threshold=10)</code>","text":"<p>Get average distance between points in the track.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the average, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Average distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_avg_pp_distance(self, threshold: float = 10) -&gt; float:\n    \"\"\"\n    Get average distance between points in the track.\n\n    :param threshold: Minimum distance between points required to  be used for the\n        average, defaults to 10\n\n    :return: Average distance\n    \"\"\"\n    return self._get_aggregated_pp_distance(\"average\", threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_avg_pp_distance_in_segment","title":"<code>get_avg_pp_distance_in_segment(n_segment=0, threshold=10)</code>","text":"<p>Get average distance between points in the segment with index n_segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement to process, defaults to 0</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the average, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Average distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_avg_pp_distance_in_segment(\n    self, n_segment: int = 0, threshold: float = 10\n) -&gt; float:\n    \"\"\"\n    Get average distance between points in the segment with index n_segment.\n\n    :param n_segment: Index of the segement to process, defaults to 0\n    :param threshold: Minimum distance between points required to  be used for the\n        average, defaults to 10\n\n    :return: Average distance\n    \"\"\"\n    return self._get_aggregated_pp_distance_in_segment(\n        \"average\", n_segment, threshold\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_closest_point","title":"<code>get_closest_point(n_segment, latitude, longitude)</code>","text":"<p>Get closest point in a segment or track to the passed latitude and longitude corrdinate</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>None | int</code> <p>Index of the segment. If None is passed the whole track is considered</p> required <code>latitude</code> <code>float</code> <p>Latitude to check</p> required <code>longitude</code> <code>float</code> <p>Longitude to check</p> required <p>Returns:</p> Type Description <code>PointDistance</code> <p>Tuple containg the point as GPXTrackPoint, the distance from the passed coordinates and the index in the segment</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_closest_point(\n    self, n_segment: None | int, latitude: float, longitude: float\n) -&gt; PointDistance:\n    \"\"\"\n    Get closest point in a segment or track to the passed latitude and longitude\n    corrdinate\n\n    :param n_segment: Index of the segment. If None is passed the whole track is\n        considered\n    :param latitude: Latitude to check\n    :param longitude: Longitude to check\n\n    :return: Tuple containg the point as GPXTrackPoint, the distance from\n        the passed coordinates and the index in the segment\n    \"\"\"\n    return get_point_distance(self.track, n_segment, latitude, longitude)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_max_pp_distance","title":"<code>get_max_pp_distance(threshold=10)</code>","text":"<p>Get maximum distance between points in the track.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the maximum, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Maximum distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_max_pp_distance(self, threshold: float = 10) -&gt; float:\n    \"\"\"\n    Get maximum distance between points in the track.\n\n    :param threshold: Minimum distance between points required to  be used for the\n        maximum, defaults to 10\n\n    :return: Maximum distance\n    \"\"\"\n    return self._get_aggregated_pp_distance(\"max\", threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_max_pp_distance_in_segment","title":"<code>get_max_pp_distance_in_segment(n_segment=0, threshold=10)</code>","text":"<p>Get maximum distance between points in the segment with index n_segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement to process, defaults to 0</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the maximum, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Maximum distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_max_pp_distance_in_segment(\n    self, n_segment: int = 0, threshold: float = 10\n) -&gt; float:\n    \"\"\"\n    Get maximum distance between points in the segment with index n_segment.\n\n    :param n_segment: Index of the segement to process, defaults to 0\n    :param threshold: Minimum distance between points required to  be used for the\n        maximum, defaults to 10\n\n    :return: Maximum distance\n    \"\"\"\n    return self._get_aggregated_pp_distance_in_segment(\"max\", n_segment, threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_point_data_in_segmnet","title":"<code>get_point_data_in_segmnet(n_segment=0)</code>","text":"<p>Get raw coordinates (latitude, longitude), times and elevations for the segement with the passed index.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[list[tuple[float, float]], None | list[float], None | list[datetime]]</code> <p>tuple with coordinates (latitude, longitude), times and elevations</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_point_data_in_segmnet(\n    self, n_segment: int = 0\n) -&gt; tuple[list[tuple[float, float]], None | list[float], None | list[datetime]]:\n    \"\"\"Get raw coordinates (latitude, longitude), times and elevations for the\n    segement with the passed index.\n\n    :param n_segment: Index of the segement, defaults to 0\n\n    :return: tuple with coordinates (latitude, longitude), times and elevations\n    \"\"\"\n    coords = []\n    elevations = []\n    times = []\n\n    for point in self.track.segments[n_segment].points:\n        coords.append((point.latitude, point.longitude))\n        if point.elevation is not None:\n            elevations.append(point.elevation)\n        if point.time is not None:\n            times.append(point.time)\n\n    if not elevations:\n        elevations = None  # type: ignore\n    elif len(coords) != len(elevations):\n        raise TrackTransformationError(\n            \"Elevation is not set for all points. This is not supported\"\n        )\n    if not times:\n        times = None  # type: ignore\n    elif len(coords) != len(times):\n        raise TrackTransformationError(\n            \"Elevation is not set for all points. This is not supported\"\n        )\n\n    return coords, elevations, times\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_segment_data","title":"<code>get_segment_data(n_segment=0)</code>","text":"<p>Get processed data for the segmeent with passed index as DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with segmenet data</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_segment_data(self, n_segment: int = 0) -&gt; pd.DataFrame:\n    \"\"\"Get processed data for the segmeent with passed index as DataFrame\n\n    :param n_segment: Index of the segement, defaults to 0\n\n    :return: DataFrame with segmenet data\n    \"\"\"\n    _, _, _, _, data = self._get_processed_segment_data(n_segment)\n\n    return data\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_segment_overview","title":"<code>get_segment_overview(n_segment=0)</code>","text":"<p>Get overall metrics for a segment</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segment the overview should be generated for, default to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>SegmentOverview</code> <p>A SegmentOverview object containing the metrics moving time and distance, total time and distance, maximum and average speed and elevation and cummulated uphill, downholl elevation</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_segment_overview(self, n_segment: int = 0) -&gt; SegmentOverview:\n    \"\"\"\n    Get overall metrics for a segment\n\n    :param n_segment: Index of the segment the overview should be generated for,\n        default to 0\n\n    :returns: A SegmentOverview object containing the metrics moving time and\n        distance, total time and distance, maximum and average speed and elevation\n        and cummulated uphill, downholl elevation\n    \"\"\"\n    (\n        time,\n        distance,\n        stopped_time,\n        stopped_distance,\n        data,\n    ) = self._get_processed_segment_data(n_segment)\n\n    max_speed = None\n    avg_speed = None\n\n    if self.track.segments[n_segment].has_times():\n        max_speed = data.speed[data.in_speed_percentile].max()\n        avg_speed = data.speed[data.in_speed_percentile].mean()\n\n    return self._create_segment_overview(\n        time=time,\n        distance=distance,\n        stopped_time=stopped_time,\n        stopped_distance=stopped_distance,\n        max_speed=max_speed,\n        avg_speed=avg_speed,\n        data=data,\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_track_data","title":"<code>get_track_data(connect_segments='forward')</code>","text":"<p>Get processed data for the track as DataFrame. Segment are indicated via the segment column.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with track data</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_track_data(\n    self, connect_segments: Literal[\"full\", \"forward\"] = \"forward\"\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Get processed data for the track as DataFrame. Segment are indicated\n    via the segment column.\n\n    :return: DataFrame with track data\n    \"\"\"\n    track_data: None | pd.DataFrame = None\n\n    _, _, _, _, track_data = self._get_processed_track_data(\n        connect_segments=connect_segments\n    )\n\n    return track_data\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_track_overview","title":"<code>get_track_overview(connect_segments='forward')</code>","text":"<p>Get overall metrics for the track. Equivalent to the sum of all segments</p> <p>Returns:</p> Type Description <code>SegmentOverview</code> <p>A SegmentOverview object containing the metrics</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_track_overview(\n    self, connect_segments: Literal[\"full\", \"forward\"] = \"forward\"\n) -&gt; SegmentOverview:\n    \"\"\"\n    Get overall metrics for the track. Equivalent to the sum of all segments\n\n    :return: A SegmentOverview object containing the metrics\n    \"\"\"\n    (\n        track_time,\n        track_distance,\n        track_stopped_time,\n        track_stopped_distance,\n        track_data,\n    ) = self._get_processed_track_data(connect_segments=connect_segments)\n\n    track_max_speed = None\n    track_avg_speed = None\n\n    if all(seg.has_times() for seg in self.track.segments):\n        track_max_speed = track_data.speed[track_data.in_speed_percentile].max()\n        track_avg_speed = track_data.speed[track_data.in_speed_percentile].mean()\n\n    return self._create_segment_overview(\n        time=track_time,\n        distance=track_distance,\n        stopped_time=track_stopped_time,\n        stopped_distance=track_stopped_distance,\n        max_speed=track_max_speed,\n        avg_speed=track_avg_speed,\n        data=track_data,  # type: ignore\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.get_xml","title":"<code>get_xml(name=None, email=None)</code>","text":"<p>Get track as .gpx file data</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>None | str</code> <p>Optional author name to be added to gpx file, defaults to None</p> <code>None</code> <code>email</code> <code>None | str</code> <p>Optional auther e-mail address to be added to the gpx file, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Content of a gpx file</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_xml(self, name: None | str = None, email: None | str = None) -&gt; str:\n    \"\"\"Get track as .gpx file data\n\n    :param name: Optional author name to be added to gpx file, defaults to None\n    :param email: Optional auther e-mail address to be added to the gpx file,\n        defaults to None\n\n    :return: Content of a gpx file\n    \"\"\"\n    gpx = GPX()\n\n    gpx.tracks = [self.track]\n    gpx.author_name = name\n    gpx.author_email = email\n\n    return gpx.to_xml()\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.interpolate_points_in_segment","title":"<code>interpolate_points_in_segment(spacing, n_segment=0, copy_extensions='copy-forward')</code>","text":"<p>Add additdion points to a segment by interpolating along the direct line between each point pair according to the passed spacing parameter. If present, elevation and time will be linearly interpolated. Extensions (Heartrate, Cadence, Power) will be interpolated according to value of copy_extensions. Optionas are:</p> <ul> <li>copy the value from the start point of the interpolation (copy-forward)</li> <li>Use value of start point for first half and last point for second half   (meet-center)</li> <li>Linear interpolation (linear)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>spacing</code> <code>float</code> <p>Minimum distance between points added by the interpolation</p> required <code>n_segment</code> <code>int</code> <p>segment in the track to use, defaults to 0</p> <code>0</code> <code>copy_extensions</code> <code>Literal['copy-forward', 'meet-center', 'linear']</code> <p>How should the extenstion (if present) be defined in the interpolated points.</p> <code>'copy-forward'</code> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def interpolate_points_in_segment(\n    self,\n    spacing: float,\n    n_segment: int = 0,\n    copy_extensions: Literal[\n        \"copy-forward\", \"meet-center\", \"linear\"\n    ] = \"copy-forward\",\n) -&gt; None:\n    \"\"\"\n    Add additdion points to a segment by interpolating along the direct line\n    between each point pair according to the passed spacing parameter. If present,\n    elevation and time will be linearly interpolated. Extensions (Heartrate,\n    Cadence, Power) will be interpolated according to value of copy_extensions.\n    Optionas are:\n\n    - copy the value from the start point of the interpolation (copy-forward)\n    - Use value of start point for first half and last point for second half\n      (meet-center)\n    - Linear interpolation (linear)\n\n\n    :param spacing: Minimum distance between points added by the interpolation\n    :param n_segment: segment in the track to use, defaults to 0\n    :param copy_extensions: How should the extenstion (if present) be defined in the\n        interpolated points.\n    \"\"\"\n    self.track.segments[n_segment] = interpolate_segment(\n        self.track.segments[n_segment], spacing, copy_extensions=copy_extensions\n    )\n\n    # Reset saved processed data\n    for key in self._processed_track_data.keys():\n        self._processed_track_data.pop(key)\n    if n_segment in self._processed_segment_data:\n        logger.debug(\n            \"Deleting saved processed segment data for segment %s\", n_segment\n        )\n        self._processed_segment_data.pop(n_segment)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.plot","title":"<code>plot(kind, *, segment=None, reduce_pp_intervals=None, use_distance_segments=None, **kwargs)</code>","text":"<p>Visualize the full track or a single segment.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Literal['profile', 'profile-slope', 'map-line', 'map-line-enhanced', 'map-segments', 'zone_summary', 'segment_zone_summary', 'segment_box', 'segment_summary']</code> <p>Kind of plot to be generated  - profile: Elevation profile of the track. May be enhanced with additional information like Velocity, Heartrate, Cadence, and Power. Pass keyword args for <code>plot_track_2d</code> - profile-slope: Elevation profile with slopes between points. Use the reduce_pp_intervals argument to reduce the number of slope intervals. Pass keyword args for <code>plot_track_with_slope</code> - map-line: Visualize coordinates on the map. Pass keyword args for <code>plot_track_line_on_map</code> - map-line-enhanced: Visualize coordinates on the map. Enhance with additional information like Elevation, Velocity, Heartrate, Cadence, and Power. Pass keyword args for <code>plot_track_enriched_on_map</code> - map-segments: Visualize coordinates on the map split into segments. Pass keyword args for <code>plot_segments_on_map</code> - zone_summary : Visualize an aggregate (time, distance, speed) value for a metric (heartrate, power, cadence) with defined zones. Pass keyword args for <code>plot_track_zones</code>, <code>aggregate</code> and <code>metric</code> are required. - segment_zone_summary : Same as \"zone_summary\" but split aggregate per segment <code>plot_segment_zones</code> - segment_box : Box plot of a metric (heartrate, power, cadence, speed, elevation) per segment. Pass keyword args for <code>plot_segments_on_map</code> <code>metric</code> is required. - segment_summary : Visualize a aggregate (total_time, total_distance, avg_speed, max_speed) per segment. Pass keyword args for <code>plot_segment_summary</code> <code>aggregate</code> is required.</p> required <code>segment</code> <code>None | int | list[int]</code> <p>Select a specific segment, multiple segments or all segmenets, defaults to None</p> <code>None</code> <code>reduce_pp_intervals</code> <code>None | int</code> <p>Optionally pass a distance in m which is used to reduce the points in a track, defaults to None</p> <code>None</code> <code>use_distance_segments</code> <code>None | float</code> <p>Ignore all segments in data and split full track into segments with passed cummulated distance in meters. If passed, segment arg must be None. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Figure (plotly)</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>If the plot prequisites are not met</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def plot(\n    self,\n    kind: Literal[\n        \"profile\",\n        \"profile-slope\",\n        \"map-line\",\n        \"map-line-enhanced\",\n        \"map-segments\",\n        \"zone_summary\",\n        \"segment_zone_summary\",\n        \"segment_box\",\n        \"segment_summary\",\n    ],\n    *,\n    segment: None | int | list[int] = None,\n    reduce_pp_intervals: None | int = None,\n    use_distance_segments: None | float = None,\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"\n    Visualize the full track or a single segment.\n\n    :param kind: Kind of plot to be generated\n\n        - profile: Elevation profile of the track. May be enhanced with additional\n          information like Velocity, Heartrate, Cadence, and Power. Pass keyword\n          args for [`plot_track_2d`][geo_track_analyzer.visualize.plot_track_2d]\n        - profile-slope: Elevation profile with slopes between points. Use the\n          reduce_pp_intervals argument to reduce the number of slope intervals.\n          Pass keyword args for\n          [`plot_track_with_slope`][geo_track_analyzer.visualize.plot_track_with_slope]\n        - map-line: Visualize coordinates on the map. Pass keyword args for\n          [`plot_track_line_on_map`][geo_track_analyzer.visualize.plot_track_line_on_map]\n        - map-line-enhanced: Visualize coordinates on the map. Enhance with\n          additional information like Elevation, Velocity, Heartrate, Cadence, and\n          Power. Pass keyword args for [`plot_track_enriched_on_map`][geo_track_analyzer.visualize.plot_track_enriched_on_map]\n        - map-segments: Visualize coordinates on the map split into segments.\n          Pass keyword args for\n          [`plot_segments_on_map`][geo_track_analyzer.visualize.plot_segments_on_map]\n        - zone_summary : Visualize an aggregate (time, distance, speed) value for a\n            metric (heartrate, power, cadence) with defined zones. Pass keyword args\n            for [`plot_track_zones`][geo_track_analyzer.visualize.plot_track_zones],\n            `aggregate` and `metric` are required.\n        - segment_zone_summary : Same as \"zone_summary\" but split aggregate per\n            segment [`plot_segment_zones`][geo_track_analyzer.visualize.plot_segment_zones]\n        - segment_box : Box plot of a metric (heartrate, power, cadence, speed,\n            elevation) per segment. Pass keyword args for [`plot_segments_on_map`][geo_track_analyzer.visualize.plot_segments_on_map]\n            `metric` is required.\n        - segment_summary : Visualize a aggregate (total_time, total_distance,\n            avg_speed, max_speed) per segment. Pass keyword args for [`plot_segment_summary`][geo_track_analyzer.visualize.plot_segment_summary]\n            `aggregate` is required.\n    :param segment: Select a specific segment, multiple segments or all segmenets,\n        defaults to None\n    :param reduce_pp_intervals: Optionally pass a distance in m which is used to\n        reduce the points in a track, defaults to None\n    :param use_distance_segments: Ignore all segments in data and split full track\n        into segments with passed cummulated distance in meters. If passed, segment\n        arg must be None. Defaults to None.\n    :raises VisualizationSetupError: If the plot prequisites are not met\n\n    :return: Figure (plotly)\n    \"\"\"\n    from geo_track_analyzer.utils.track import generate_distance_segments\n\n    if use_distance_segments is not None and segment is not None:\n        raise VisualizationSetupError(\n            f\"use_distance_segments {use_distance_segments} cannot be passed with \"\n            f\"segment {segment}.\"\n        )\n\n    valid_kinds = [\n        \"profile\",\n        \"profile-slope\",\n        \"map-line\",\n        \"map-line-enhanced\",\n        \"map-segments\",\n        \"zone_summary\",\n        \"segment_zone_summary\",\n        \"segment_box\",\n        \"segment_summary\",\n    ]\n\n    require_elevation = [\"profile\", \"profile-slope\"]\n    connect_segment_full = [\"map-segments\"]\n    if kind not in valid_kinds:\n        raise VisualizationSetupError(\n            f\"Kind {kind} is not valid. Pass on of {','.join(valid_kinds)}\"\n        )\n\n    if kind in [\"zone_summary\", \"segment_zone_summary\"] and not all(\n        key in kwargs.keys() for key in [\"metric\", \"aggregate\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** and **aggregate** need to be passed\"\n        )\n    if kind in [\"segment_box\"] and not all(\n        key in kwargs.keys() for key in [\"metric\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** needs to be passed\"\n        )\n    if kind in [\"segment_summary\"] and not all(\n        key in kwargs.keys() for key in [\"aggregate\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** needs to be passed\"\n        )\n\n    if segment is None:\n        from geo_track_analyzer.utils.track import extract_track_data_for_plot\n\n        data = extract_track_data_for_plot(\n            track=self,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n            connect_segments=\"full\" if kind in connect_segment_full else \"forward\",\n        )\n    elif isinstance(segment, int):\n        from geo_track_analyzer.utils.track import extract_segment_data_for_plot\n\n        data = extract_segment_data_for_plot(\n            track=self,\n            segment=segment,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n        )\n    else:\n        from geo_track_analyzer.utils.track import (\n            extract_multiple_segment_data_for_plot,\n        )\n\n        data = extract_multiple_segment_data_for_plot(\n            track=self,\n            segments=segment,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n        )\n\n    if use_distance_segments is not None:\n        data = generate_distance_segments(data, use_distance_segments)\n\n    fig: Figure\n    if kind == \"profile\":\n        fig = plot_track_2d(data=data, **kwargs)\n    elif kind == \"profile-slope\":\n        fig = plot_track_with_slope(data=data, **kwargs)\n    elif kind == \"map-line\":\n        fig = plot_track_line_on_map(data=data, **kwargs)\n    elif kind == \"map-line-enhanced\":\n        fig = plot_track_enriched_on_map(data=data, **kwargs)\n    elif kind == \"map-segments\":\n        fig = plot_segments_on_map(data=data, **kwargs)\n    elif kind == \"zone_summary\":\n        fig = plot_track_zones(data=data, **kwargs)\n    elif kind == \"segment_zone_summary\":\n        fig = plot_segment_zones(data=data, **kwargs)\n    elif kind == \"segment_summary\":\n        fig = plot_segment_summary(data=data, **kwargs)\n    elif kind == \"segment_box\":\n        fig = plot_segment_box_summary(data=data, **kwargs)\n\n    return fig\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.PyTrack.split","title":"<code>split(coords, distance_threshold=20)</code>","text":"<p>Split the track at the passed coordinates. The distance_threshold parameter defines the maximum distance between the passed coordingates and the closest point in the track.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>tuple[float, float]</code> <p>Latitude, Longitude point at which the split should be made</p> required <code>distance_threshold</code> <code>float</code> <p>Maximum distance between coords and closest point, defaults to 20</p> <code>20</code> <p>Raises:</p> Type Description <code>TrackTransformationError</code> <p>If distance exceeds threshold</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def split(\n    self, coords: tuple[float, float], distance_threshold: float = 20\n) -&gt; None:\n    \"\"\"\n    Split the track at the passed coordinates. The distance_threshold parameter\n    defines the maximum distance between the passed coordingates and the closest\n    point in the track.\n\n    :param coords: Latitude, Longitude point at which the split should be made\n    :param distance_threshold: Maximum distance between coords and closest point,\n        defaults to 20\n\n    :raises TrackTransformationError: If distance exceeds threshold\n    \"\"\"\n    lat, long = coords\n    point_distance = get_point_distance(\n        self.track, None, latitude=lat, longitude=long\n    )\n\n    if point_distance.distance &gt; distance_threshold:\n        raise TrackTransformationError(\n            f\"Closes point in track has distance {point_distance.distance:.2f}m \"\n            \"from passed coordingates\"\n        )\n    # Split the segment. The closest point should be the first\n    # point of the second segment\n    pre_segment, post_segment = self.track.segments[\n        point_distance.segment_idx\n    ].split(point_distance.segment_point_idx - 1)\n\n    self.track.segments[point_distance.segment_idx] = pre_segment\n    self.track.segments.insert(point_distance.segment_idx + 1, post_segment)\n\n    self._processed_segment_data = {}\n    self._processed_track_data = {}\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack","title":"<code>SegmentTrack(segment, stopped_speed_threshold=1, max_speed_percentile=95, heartrate_zones=None, power_zones=None, cadence_zones=None)</code>","text":"<p>             Bases: <code>Track</code></p> <p>Track that should be initialized by loading a PGXTrackSegment object</p> <p>Wrap a GPXTrackSegment into a Track object</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>GPXTrackSegment</code> <p>GPXTrackSegment</p> required <code>stopped_speed_threshold</code> <code>float</code> <p>Minium speed required for a point to be count as moving, defaults to 1</p> <code>1</code> <code>max_speed_percentile</code> <code>int</code> <p>Points with speed outside of the percentile are not counted when analyzing the track, defaults to 95</p> <code>95</code> <code>heartrate_zones</code> <code>None | Zones</code> <p>Optional heartrate Zones, defaults to None</p> <code>None</code> <code>power_zones</code> <code>None | Zones</code> <p>Optional power Zones, defaults to None</p> <code>None</code> <code>cadence_zones</code> <code>None | Zones</code> <p>Optional cadence Zones, defaults to None</p> <code>None</code> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def __init__(\n    self,\n    segment: GPXTrackSegment,\n    stopped_speed_threshold: float = 1,\n    max_speed_percentile: int = 95,\n    heartrate_zones: None | Zones = None,\n    power_zones: None | Zones = None,\n    cadence_zones: None | Zones = None,\n) -&gt; None:\n    \"\"\"Wrap a GPXTrackSegment into a Track object\n\n    :param segment: GPXTrackSegment\n    :param stopped_speed_threshold: Minium speed required for a point to be count\n        as moving, defaults to 1\n    :param max_speed_percentile: Points with speed outside of the percentile are not\n        counted when analyzing the track, defaults to 95\n    :param heartrate_zones: Optional heartrate Zones, defaults to None\n    :param power_zones: Optional power Zones, defaults to None\n    :param cadence_zones: Optional cadence Zones, defaults to None\n    \"\"\"\n    super().__init__(\n        stopped_speed_threshold=stopped_speed_threshold,\n        max_speed_percentile=max_speed_percentile,\n        heartrate_zones=heartrate_zones,\n        power_zones=power_zones,\n        cadence_zones=cadence_zones,\n    )\n    gpx = GPX()\n\n    gpx_track = GPXTrack()\n    gpx.tracks.append(gpx_track)\n\n    gpx_track.segments.append(segment)\n\n    self._track = gpx.tracks[0]\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.add_segmeent","title":"<code>add_segmeent(segment)</code>","text":"<p>Add a new segment ot the track</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>GPXTrackSegment</code> <p>GPXTracksegment to be added</p> required Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def add_segmeent(self, segment: GPXTrackSegment) -&gt; None:\n    \"\"\"Add a new segment ot the track\n\n    :param segment: GPXTracksegment to be added\n    \"\"\"\n    self.track.segments.append(segment)\n    logger.info(\"Added segment with postition: %s\", len(self.track.segments))\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.find_overlap_with_segment","title":"<code>find_overlap_with_segment(n_segment, match_track, match_track_segment=0, width=50, overlap_threshold=0.75, max_queue_normalize=5, merge_subsegments=5, extensions_interpolation='copy-forward')</code>","text":"<p>Find overlap of a segment of the track with a segment in another track.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Segment in the track that sould be used as base for the comparison</p> required <code>match_track</code> <code>Track</code> <p>Track object containing the segment to be matched</p> required <code>match_track_segment</code> <code>int</code> <p>Segment on the passed track that should be matched to the segment in this track, defaults to 0</p> <code>0</code> <code>width</code> <code>float</code> <p>Width (in meters) of the grid that will be filled to estimate the overalp , defaults to 50</p> <code>50</code> <code>overlap_threshold</code> <code>float</code> <p>Minimum overlap (as fracrtion) required to return the overlap data, defaults to 0.75</p> <code>0.75</code> <code>max_queue_normalize</code> <code>int</code> <p>Minimum number of successive points in the segment between two points falling into same plate bin, defaults to 5</p> <code>5</code> <code>merge_subsegments</code> <code>int</code> <p>Number of points between sub segments allowed for merging the segments, defaults to 5</p> <code>5</code> <code>extensions_interpolation</code> <code>Literal['copy-forward', 'meet-center', 'linear']</code> <p>How should the extenstion (if present) be defined in the interpolated points, defaults to copy-forward</p> <code>'copy-forward'</code> <p>Returns:</p> Type Description <code>Sequence[tuple[Track, float, bool]]</code> <p>Tuple containing a Track with the overlapping points, the overlap in percent, and the direction of the overlap</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def find_overlap_with_segment(\n    self,\n    n_segment: int,\n    match_track: Track,\n    match_track_segment: int = 0,\n    width: float = 50,\n    overlap_threshold: float = 0.75,\n    max_queue_normalize: int = 5,\n    merge_subsegments: int = 5,\n    extensions_interpolation: Literal[\n        \"copy-forward\", \"meet-center\", \"linear\"\n    ] = \"copy-forward\",\n) -&gt; Sequence[tuple[Track, float, bool]]:\n    \"\"\"Find overlap of a segment of the track with a segment in another track.\n\n    :param n_segment: Segment in the track that sould be used as base for the\n        comparison\n    :param match_track: Track object containing the segment to be matched\n    :param match_track_segment: Segment on the passed track that should be matched\n        to the segment in this track, defaults to 0\n    :param width: Width (in meters) of the grid that will be filled to estimate\n        the overalp , defaults to 50\n    :param overlap_threshold: Minimum overlap (as fracrtion) required to return the\n        overlap data, defaults to 0.75\n    :param max_queue_normalize: Minimum number of successive points in the segment\n        between two points falling into same plate bin, defaults to 5\n    :param merge_subsegments: Number of points between sub segments allowed\n        for merging the segments, defaults to 5\n    :param extensions_interpolation: How should the extenstion (if present) be\n        defined in the interpolated points, defaults to copy-forward\n\n    :return: Tuple containing a Track with the overlapping points, the overlap in\n        percent, and the direction of the overlap\n    \"\"\"\n    max_distance_self = self.get_max_pp_distance_in_segment(n_segment)\n\n    segment_self = self.track.segments[n_segment]\n    if max_distance_self &gt; width:\n        segment_self = interpolate_segment(\n            segment_self, width / 2, copy_extensions=extensions_interpolation\n        )\n\n    max_distance_match = match_track.get_max_pp_distance_in_segment(\n        match_track_segment\n    )\n    segment_match = match_track.track.segments[match_track_segment]\n    if max_distance_match &gt; width:\n        segment_match = interpolate_segment(\n            segment_match, width / 2, copy_extensions=extensions_interpolation\n        )\n\n    logger.info(\"Looking for overlapping segments\")\n    segment_overlaps = get_segment_overlap(\n        segment_self,\n        segment_match,\n        width,\n        max_queue_normalize,\n        merge_subsegments,\n        overlap_threshold,\n    )\n\n    matched_tracks: list[tuple[Track, float, bool]] = []\n    for overlap in segment_overlaps:\n        logger.info(\"Found: %s\", overlap)\n        matched_segment = GPXTrackSegment()\n        # TODO: Might need to go up to overlap.end_idx + 1?\n        matched_segment.points = self.track.segments[n_segment].points[\n            overlap.start_idx : overlap.end_idx\n        ]\n        matched_tracks.append(\n            (\n                SegmentTrack(\n                    matched_segment,\n                    stopped_speed_threshold=self.stopped_speed_threshold,\n                    max_speed_percentile=self.max_speed_percentile,\n                ),\n                overlap.overlap,\n                overlap.inverse,\n            )\n        )\n    return matched_tracks\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_avg_pp_distance","title":"<code>get_avg_pp_distance(threshold=10)</code>","text":"<p>Get average distance between points in the track.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the average, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Average distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_avg_pp_distance(self, threshold: float = 10) -&gt; float:\n    \"\"\"\n    Get average distance between points in the track.\n\n    :param threshold: Minimum distance between points required to  be used for the\n        average, defaults to 10\n\n    :return: Average distance\n    \"\"\"\n    return self._get_aggregated_pp_distance(\"average\", threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_avg_pp_distance_in_segment","title":"<code>get_avg_pp_distance_in_segment(n_segment=0, threshold=10)</code>","text":"<p>Get average distance between points in the segment with index n_segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement to process, defaults to 0</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the average, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Average distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_avg_pp_distance_in_segment(\n    self, n_segment: int = 0, threshold: float = 10\n) -&gt; float:\n    \"\"\"\n    Get average distance between points in the segment with index n_segment.\n\n    :param n_segment: Index of the segement to process, defaults to 0\n    :param threshold: Minimum distance between points required to  be used for the\n        average, defaults to 10\n\n    :return: Average distance\n    \"\"\"\n    return self._get_aggregated_pp_distance_in_segment(\n        \"average\", n_segment, threshold\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_closest_point","title":"<code>get_closest_point(n_segment, latitude, longitude)</code>","text":"<p>Get closest point in a segment or track to the passed latitude and longitude corrdinate</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>None | int</code> <p>Index of the segment. If None is passed the whole track is considered</p> required <code>latitude</code> <code>float</code> <p>Latitude to check</p> required <code>longitude</code> <code>float</code> <p>Longitude to check</p> required <p>Returns:</p> Type Description <code>PointDistance</code> <p>Tuple containg the point as GPXTrackPoint, the distance from the passed coordinates and the index in the segment</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_closest_point(\n    self, n_segment: None | int, latitude: float, longitude: float\n) -&gt; PointDistance:\n    \"\"\"\n    Get closest point in a segment or track to the passed latitude and longitude\n    corrdinate\n\n    :param n_segment: Index of the segment. If None is passed the whole track is\n        considered\n    :param latitude: Latitude to check\n    :param longitude: Longitude to check\n\n    :return: Tuple containg the point as GPXTrackPoint, the distance from\n        the passed coordinates and the index in the segment\n    \"\"\"\n    return get_point_distance(self.track, n_segment, latitude, longitude)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_max_pp_distance","title":"<code>get_max_pp_distance(threshold=10)</code>","text":"<p>Get maximum distance between points in the track.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the maximum, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Maximum distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_max_pp_distance(self, threshold: float = 10) -&gt; float:\n    \"\"\"\n    Get maximum distance between points in the track.\n\n    :param threshold: Minimum distance between points required to  be used for the\n        maximum, defaults to 10\n\n    :return: Maximum distance\n    \"\"\"\n    return self._get_aggregated_pp_distance(\"max\", threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_max_pp_distance_in_segment","title":"<code>get_max_pp_distance_in_segment(n_segment=0, threshold=10)</code>","text":"<p>Get maximum distance between points in the segment with index n_segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement to process, defaults to 0</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between points required to  be used for the maximum, defaults to 10</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Maximum distance</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_max_pp_distance_in_segment(\n    self, n_segment: int = 0, threshold: float = 10\n) -&gt; float:\n    \"\"\"\n    Get maximum distance between points in the segment with index n_segment.\n\n    :param n_segment: Index of the segement to process, defaults to 0\n    :param threshold: Minimum distance between points required to  be used for the\n        maximum, defaults to 10\n\n    :return: Maximum distance\n    \"\"\"\n    return self._get_aggregated_pp_distance_in_segment(\"max\", n_segment, threshold)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_point_data_in_segmnet","title":"<code>get_point_data_in_segmnet(n_segment=0)</code>","text":"<p>Get raw coordinates (latitude, longitude), times and elevations for the segement with the passed index.</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[list[tuple[float, float]], None | list[float], None | list[datetime]]</code> <p>tuple with coordinates (latitude, longitude), times and elevations</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_point_data_in_segmnet(\n    self, n_segment: int = 0\n) -&gt; tuple[list[tuple[float, float]], None | list[float], None | list[datetime]]:\n    \"\"\"Get raw coordinates (latitude, longitude), times and elevations for the\n    segement with the passed index.\n\n    :param n_segment: Index of the segement, defaults to 0\n\n    :return: tuple with coordinates (latitude, longitude), times and elevations\n    \"\"\"\n    coords = []\n    elevations = []\n    times = []\n\n    for point in self.track.segments[n_segment].points:\n        coords.append((point.latitude, point.longitude))\n        if point.elevation is not None:\n            elevations.append(point.elevation)\n        if point.time is not None:\n            times.append(point.time)\n\n    if not elevations:\n        elevations = None  # type: ignore\n    elif len(coords) != len(elevations):\n        raise TrackTransformationError(\n            \"Elevation is not set for all points. This is not supported\"\n        )\n    if not times:\n        times = None  # type: ignore\n    elif len(coords) != len(times):\n        raise TrackTransformationError(\n            \"Elevation is not set for all points. This is not supported\"\n        )\n\n    return coords, elevations, times\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_segment_data","title":"<code>get_segment_data(n_segment=0)</code>","text":"<p>Get processed data for the segmeent with passed index as DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segement, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with segmenet data</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_segment_data(self, n_segment: int = 0) -&gt; pd.DataFrame:\n    \"\"\"Get processed data for the segmeent with passed index as DataFrame\n\n    :param n_segment: Index of the segement, defaults to 0\n\n    :return: DataFrame with segmenet data\n    \"\"\"\n    _, _, _, _, data = self._get_processed_segment_data(n_segment)\n\n    return data\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_segment_overview","title":"<code>get_segment_overview(n_segment=0)</code>","text":"<p>Get overall metrics for a segment</p> <p>Parameters:</p> Name Type Description Default <code>n_segment</code> <code>int</code> <p>Index of the segment the overview should be generated for, default to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>SegmentOverview</code> <p>A SegmentOverview object containing the metrics moving time and distance, total time and distance, maximum and average speed and elevation and cummulated uphill, downholl elevation</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_segment_overview(self, n_segment: int = 0) -&gt; SegmentOverview:\n    \"\"\"\n    Get overall metrics for a segment\n\n    :param n_segment: Index of the segment the overview should be generated for,\n        default to 0\n\n    :returns: A SegmentOverview object containing the metrics moving time and\n        distance, total time and distance, maximum and average speed and elevation\n        and cummulated uphill, downholl elevation\n    \"\"\"\n    (\n        time,\n        distance,\n        stopped_time,\n        stopped_distance,\n        data,\n    ) = self._get_processed_segment_data(n_segment)\n\n    max_speed = None\n    avg_speed = None\n\n    if self.track.segments[n_segment].has_times():\n        max_speed = data.speed[data.in_speed_percentile].max()\n        avg_speed = data.speed[data.in_speed_percentile].mean()\n\n    return self._create_segment_overview(\n        time=time,\n        distance=distance,\n        stopped_time=stopped_time,\n        stopped_distance=stopped_distance,\n        max_speed=max_speed,\n        avg_speed=avg_speed,\n        data=data,\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_track_data","title":"<code>get_track_data(connect_segments='forward')</code>","text":"<p>Get processed data for the track as DataFrame. Segment are indicated via the segment column.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with track data</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_track_data(\n    self, connect_segments: Literal[\"full\", \"forward\"] = \"forward\"\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Get processed data for the track as DataFrame. Segment are indicated\n    via the segment column.\n\n    :return: DataFrame with track data\n    \"\"\"\n    track_data: None | pd.DataFrame = None\n\n    _, _, _, _, track_data = self._get_processed_track_data(\n        connect_segments=connect_segments\n    )\n\n    return track_data\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_track_overview","title":"<code>get_track_overview(connect_segments='forward')</code>","text":"<p>Get overall metrics for the track. Equivalent to the sum of all segments</p> <p>Returns:</p> Type Description <code>SegmentOverview</code> <p>A SegmentOverview object containing the metrics</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_track_overview(\n    self, connect_segments: Literal[\"full\", \"forward\"] = \"forward\"\n) -&gt; SegmentOverview:\n    \"\"\"\n    Get overall metrics for the track. Equivalent to the sum of all segments\n\n    :return: A SegmentOverview object containing the metrics\n    \"\"\"\n    (\n        track_time,\n        track_distance,\n        track_stopped_time,\n        track_stopped_distance,\n        track_data,\n    ) = self._get_processed_track_data(connect_segments=connect_segments)\n\n    track_max_speed = None\n    track_avg_speed = None\n\n    if all(seg.has_times() for seg in self.track.segments):\n        track_max_speed = track_data.speed[track_data.in_speed_percentile].max()\n        track_avg_speed = track_data.speed[track_data.in_speed_percentile].mean()\n\n    return self._create_segment_overview(\n        time=track_time,\n        distance=track_distance,\n        stopped_time=track_stopped_time,\n        stopped_distance=track_stopped_distance,\n        max_speed=track_max_speed,\n        avg_speed=track_avg_speed,\n        data=track_data,  # type: ignore\n    )\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.get_xml","title":"<code>get_xml(name=None, email=None)</code>","text":"<p>Get track as .gpx file data</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>None | str</code> <p>Optional author name to be added to gpx file, defaults to None</p> <code>None</code> <code>email</code> <code>None | str</code> <p>Optional auther e-mail address to be added to the gpx file, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Content of a gpx file</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def get_xml(self, name: None | str = None, email: None | str = None) -&gt; str:\n    \"\"\"Get track as .gpx file data\n\n    :param name: Optional author name to be added to gpx file, defaults to None\n    :param email: Optional auther e-mail address to be added to the gpx file,\n        defaults to None\n\n    :return: Content of a gpx file\n    \"\"\"\n    gpx = GPX()\n\n    gpx.tracks = [self.track]\n    gpx.author_name = name\n    gpx.author_email = email\n\n    return gpx.to_xml()\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.interpolate_points_in_segment","title":"<code>interpolate_points_in_segment(spacing, n_segment=0, copy_extensions='copy-forward')</code>","text":"<p>Add additdion points to a segment by interpolating along the direct line between each point pair according to the passed spacing parameter. If present, elevation and time will be linearly interpolated. Extensions (Heartrate, Cadence, Power) will be interpolated according to value of copy_extensions. Optionas are:</p> <ul> <li>copy the value from the start point of the interpolation (copy-forward)</li> <li>Use value of start point for first half and last point for second half   (meet-center)</li> <li>Linear interpolation (linear)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>spacing</code> <code>float</code> <p>Minimum distance between points added by the interpolation</p> required <code>n_segment</code> <code>int</code> <p>segment in the track to use, defaults to 0</p> <code>0</code> <code>copy_extensions</code> <code>Literal['copy-forward', 'meet-center', 'linear']</code> <p>How should the extenstion (if present) be defined in the interpolated points.</p> <code>'copy-forward'</code> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def interpolate_points_in_segment(\n    self,\n    spacing: float,\n    n_segment: int = 0,\n    copy_extensions: Literal[\n        \"copy-forward\", \"meet-center\", \"linear\"\n    ] = \"copy-forward\",\n) -&gt; None:\n    \"\"\"\n    Add additdion points to a segment by interpolating along the direct line\n    between each point pair according to the passed spacing parameter. If present,\n    elevation and time will be linearly interpolated. Extensions (Heartrate,\n    Cadence, Power) will be interpolated according to value of copy_extensions.\n    Optionas are:\n\n    - copy the value from the start point of the interpolation (copy-forward)\n    - Use value of start point for first half and last point for second half\n      (meet-center)\n    - Linear interpolation (linear)\n\n\n    :param spacing: Minimum distance between points added by the interpolation\n    :param n_segment: segment in the track to use, defaults to 0\n    :param copy_extensions: How should the extenstion (if present) be defined in the\n        interpolated points.\n    \"\"\"\n    self.track.segments[n_segment] = interpolate_segment(\n        self.track.segments[n_segment], spacing, copy_extensions=copy_extensions\n    )\n\n    # Reset saved processed data\n    for key in self._processed_track_data.keys():\n        self._processed_track_data.pop(key)\n    if n_segment in self._processed_segment_data:\n        logger.debug(\n            \"Deleting saved processed segment data for segment %s\", n_segment\n        )\n        self._processed_segment_data.pop(n_segment)\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.plot","title":"<code>plot(kind, *, segment=None, reduce_pp_intervals=None, use_distance_segments=None, **kwargs)</code>","text":"<p>Visualize the full track or a single segment.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Literal['profile', 'profile-slope', 'map-line', 'map-line-enhanced', 'map-segments', 'zone_summary', 'segment_zone_summary', 'segment_box', 'segment_summary']</code> <p>Kind of plot to be generated  - profile: Elevation profile of the track. May be enhanced with additional information like Velocity, Heartrate, Cadence, and Power. Pass keyword args for <code>plot_track_2d</code> - profile-slope: Elevation profile with slopes between points. Use the reduce_pp_intervals argument to reduce the number of slope intervals. Pass keyword args for <code>plot_track_with_slope</code> - map-line: Visualize coordinates on the map. Pass keyword args for <code>plot_track_line_on_map</code> - map-line-enhanced: Visualize coordinates on the map. Enhance with additional information like Elevation, Velocity, Heartrate, Cadence, and Power. Pass keyword args for <code>plot_track_enriched_on_map</code> - map-segments: Visualize coordinates on the map split into segments. Pass keyword args for <code>plot_segments_on_map</code> - zone_summary : Visualize an aggregate (time, distance, speed) value for a metric (heartrate, power, cadence) with defined zones. Pass keyword args for <code>plot_track_zones</code>, <code>aggregate</code> and <code>metric</code> are required. - segment_zone_summary : Same as \"zone_summary\" but split aggregate per segment <code>plot_segment_zones</code> - segment_box : Box plot of a metric (heartrate, power, cadence, speed, elevation) per segment. Pass keyword args for <code>plot_segments_on_map</code> <code>metric</code> is required. - segment_summary : Visualize a aggregate (total_time, total_distance, avg_speed, max_speed) per segment. Pass keyword args for <code>plot_segment_summary</code> <code>aggregate</code> is required.</p> required <code>segment</code> <code>None | int | list[int]</code> <p>Select a specific segment, multiple segments or all segmenets, defaults to None</p> <code>None</code> <code>reduce_pp_intervals</code> <code>None | int</code> <p>Optionally pass a distance in m which is used to reduce the points in a track, defaults to None</p> <code>None</code> <code>use_distance_segments</code> <code>None | float</code> <p>Ignore all segments in data and split full track into segments with passed cummulated distance in meters. If passed, segment arg must be None. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Figure (plotly)</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>If the plot prequisites are not met</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def plot(\n    self,\n    kind: Literal[\n        \"profile\",\n        \"profile-slope\",\n        \"map-line\",\n        \"map-line-enhanced\",\n        \"map-segments\",\n        \"zone_summary\",\n        \"segment_zone_summary\",\n        \"segment_box\",\n        \"segment_summary\",\n    ],\n    *,\n    segment: None | int | list[int] = None,\n    reduce_pp_intervals: None | int = None,\n    use_distance_segments: None | float = None,\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"\n    Visualize the full track or a single segment.\n\n    :param kind: Kind of plot to be generated\n\n        - profile: Elevation profile of the track. May be enhanced with additional\n          information like Velocity, Heartrate, Cadence, and Power. Pass keyword\n          args for [`plot_track_2d`][geo_track_analyzer.visualize.plot_track_2d]\n        - profile-slope: Elevation profile with slopes between points. Use the\n          reduce_pp_intervals argument to reduce the number of slope intervals.\n          Pass keyword args for\n          [`plot_track_with_slope`][geo_track_analyzer.visualize.plot_track_with_slope]\n        - map-line: Visualize coordinates on the map. Pass keyword args for\n          [`plot_track_line_on_map`][geo_track_analyzer.visualize.plot_track_line_on_map]\n        - map-line-enhanced: Visualize coordinates on the map. Enhance with\n          additional information like Elevation, Velocity, Heartrate, Cadence, and\n          Power. Pass keyword args for [`plot_track_enriched_on_map`][geo_track_analyzer.visualize.plot_track_enriched_on_map]\n        - map-segments: Visualize coordinates on the map split into segments.\n          Pass keyword args for\n          [`plot_segments_on_map`][geo_track_analyzer.visualize.plot_segments_on_map]\n        - zone_summary : Visualize an aggregate (time, distance, speed) value for a\n            metric (heartrate, power, cadence) with defined zones. Pass keyword args\n            for [`plot_track_zones`][geo_track_analyzer.visualize.plot_track_zones],\n            `aggregate` and `metric` are required.\n        - segment_zone_summary : Same as \"zone_summary\" but split aggregate per\n            segment [`plot_segment_zones`][geo_track_analyzer.visualize.plot_segment_zones]\n        - segment_box : Box plot of a metric (heartrate, power, cadence, speed,\n            elevation) per segment. Pass keyword args for [`plot_segments_on_map`][geo_track_analyzer.visualize.plot_segments_on_map]\n            `metric` is required.\n        - segment_summary : Visualize a aggregate (total_time, total_distance,\n            avg_speed, max_speed) per segment. Pass keyword args for [`plot_segment_summary`][geo_track_analyzer.visualize.plot_segment_summary]\n            `aggregate` is required.\n    :param segment: Select a specific segment, multiple segments or all segmenets,\n        defaults to None\n    :param reduce_pp_intervals: Optionally pass a distance in m which is used to\n        reduce the points in a track, defaults to None\n    :param use_distance_segments: Ignore all segments in data and split full track\n        into segments with passed cummulated distance in meters. If passed, segment\n        arg must be None. Defaults to None.\n    :raises VisualizationSetupError: If the plot prequisites are not met\n\n    :return: Figure (plotly)\n    \"\"\"\n    from geo_track_analyzer.utils.track import generate_distance_segments\n\n    if use_distance_segments is not None and segment is not None:\n        raise VisualizationSetupError(\n            f\"use_distance_segments {use_distance_segments} cannot be passed with \"\n            f\"segment {segment}.\"\n        )\n\n    valid_kinds = [\n        \"profile\",\n        \"profile-slope\",\n        \"map-line\",\n        \"map-line-enhanced\",\n        \"map-segments\",\n        \"zone_summary\",\n        \"segment_zone_summary\",\n        \"segment_box\",\n        \"segment_summary\",\n    ]\n\n    require_elevation = [\"profile\", \"profile-slope\"]\n    connect_segment_full = [\"map-segments\"]\n    if kind not in valid_kinds:\n        raise VisualizationSetupError(\n            f\"Kind {kind} is not valid. Pass on of {','.join(valid_kinds)}\"\n        )\n\n    if kind in [\"zone_summary\", \"segment_zone_summary\"] and not all(\n        key in kwargs.keys() for key in [\"metric\", \"aggregate\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** and **aggregate** need to be passed\"\n        )\n    if kind in [\"segment_box\"] and not all(\n        key in kwargs.keys() for key in [\"metric\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** needs to be passed\"\n        )\n    if kind in [\"segment_summary\"] and not all(\n        key in kwargs.keys() for key in [\"aggregate\"]\n    ):\n        raise VisualizationSetupError(\n            f\"If {kind} is passed, **metric** needs to be passed\"\n        )\n\n    if segment is None:\n        from geo_track_analyzer.utils.track import extract_track_data_for_plot\n\n        data = extract_track_data_for_plot(\n            track=self,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n            connect_segments=\"full\" if kind in connect_segment_full else \"forward\",\n        )\n    elif isinstance(segment, int):\n        from geo_track_analyzer.utils.track import extract_segment_data_for_plot\n\n        data = extract_segment_data_for_plot(\n            track=self,\n            segment=segment,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n        )\n    else:\n        from geo_track_analyzer.utils.track import (\n            extract_multiple_segment_data_for_plot,\n        )\n\n        data = extract_multiple_segment_data_for_plot(\n            track=self,\n            segments=segment,\n            kind=kind,\n            require_elevation=require_elevation,\n            intervals=reduce_pp_intervals,\n        )\n\n    if use_distance_segments is not None:\n        data = generate_distance_segments(data, use_distance_segments)\n\n    fig: Figure\n    if kind == \"profile\":\n        fig = plot_track_2d(data=data, **kwargs)\n    elif kind == \"profile-slope\":\n        fig = plot_track_with_slope(data=data, **kwargs)\n    elif kind == \"map-line\":\n        fig = plot_track_line_on_map(data=data, **kwargs)\n    elif kind == \"map-line-enhanced\":\n        fig = plot_track_enriched_on_map(data=data, **kwargs)\n    elif kind == \"map-segments\":\n        fig = plot_segments_on_map(data=data, **kwargs)\n    elif kind == \"zone_summary\":\n        fig = plot_track_zones(data=data, **kwargs)\n    elif kind == \"segment_zone_summary\":\n        fig = plot_segment_zones(data=data, **kwargs)\n    elif kind == \"segment_summary\":\n        fig = plot_segment_summary(data=data, **kwargs)\n    elif kind == \"segment_box\":\n        fig = plot_segment_box_summary(data=data, **kwargs)\n\n    return fig\n</code></pre>"},{"location":"api_tracks/#geo_track_analyzer.track.SegmentTrack.split","title":"<code>split(coords, distance_threshold=20)</code>","text":"<p>Split the track at the passed coordinates. The distance_threshold parameter defines the maximum distance between the passed coordingates and the closest point in the track.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>tuple[float, float]</code> <p>Latitude, Longitude point at which the split should be made</p> required <code>distance_threshold</code> <code>float</code> <p>Maximum distance between coords and closest point, defaults to 20</p> <code>20</code> <p>Raises:</p> Type Description <code>TrackTransformationError</code> <p>If distance exceeds threshold</p> Source code in <code>geo_track_analyzer/track.py</code> <pre><code>def split(\n    self, coords: tuple[float, float], distance_threshold: float = 20\n) -&gt; None:\n    \"\"\"\n    Split the track at the passed coordinates. The distance_threshold parameter\n    defines the maximum distance between the passed coordingates and the closest\n    point in the track.\n\n    :param coords: Latitude, Longitude point at which the split should be made\n    :param distance_threshold: Maximum distance between coords and closest point,\n        defaults to 20\n\n    :raises TrackTransformationError: If distance exceeds threshold\n    \"\"\"\n    lat, long = coords\n    point_distance = get_point_distance(\n        self.track, None, latitude=lat, longitude=long\n    )\n\n    if point_distance.distance &gt; distance_threshold:\n        raise TrackTransformationError(\n            f\"Closes point in track has distance {point_distance.distance:.2f}m \"\n            \"from passed coordingates\"\n        )\n    # Split the segment. The closest point should be the first\n    # point of the second segment\n    pre_segment, post_segment = self.track.segments[\n        point_distance.segment_idx\n    ].split(point_distance.segment_point_idx - 1)\n\n    self.track.segments[point_distance.segment_idx] = pre_segment\n    self.track.segments.insert(point_distance.segment_idx + 1, post_segment)\n\n    self._processed_segment_data = {}\n    self._processed_track_data = {}\n</code></pre>"},{"location":"api_visualizations/","title":"Visualization Reference","text":""},{"location":"api_visualizations/#map-visualizations","title":"Map visualizations","text":""},{"location":"api_visualizations/#geo_track_analyzer.visualize.plot_track_line_on_map","title":"<code>plot_track_line_on_map(data, *, zoom=13, height=None, width=None, line_width=2.5, map_style='open-street-map', **kwargs)</code>","text":"<p>Plot the track line on a map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing latitude and longitude data.</p> required <code>zoom</code> <code>int</code> <p>Zoom level for the map, defaults to 13</p> <code>13</code> <code>height</code> <code>None | int</code> <p>Height of the plot, defaults to None</p> <code>None</code> <code>width</code> <code>None | int</code> <p>Width of the plot, defaults to None</p> <code>None</code> <code>line_width</code> <code>float</code> <p>Width of the line on the map, defaults to 2.5</p> <code>2.5</code> <code>map_style</code> <code>str</code> <p>Valid map_style for plotly mapbox_style, defaults to open-street-map</p> <code>'open-street-map'</code> <code>kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object.</p> Source code in <code>geo_track_analyzer/visualize/map.py</code> <pre><code>def plot_track_line_on_map(\n    data: pd.DataFrame,\n    *,\n    zoom: int = 13,\n    height: None | int = None,\n    width: None | int = None,\n    line_width: float = 2.5,\n    map_style: str = \"open-street-map\",\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"\n    Plot the track line on a map.\n\n    :param data: DataFrame containing latitude and longitude data.\n    :param zoom: Zoom level for the map, defaults to 13\n    :param height: Height of the plot, defaults to None\n    :param width: Width of the plot, defaults to None\n    :param line_width: Width of the line on the map, defaults to 2.5\n    :param map_style: Valid map_style for plotly mapbox_style, defaults to\n        open-street-map\n    :param kwargs: Additional keyword arguments.\n\n    :return: Plotly Figure object.\n    \"\"\"\n    mask = data.moving\n\n    center_lat, center_lon = center_geolocation(\n        [(r[\"latitude\"], r[\"longitude\"]) for r in data[mask].to_dict(\"records\")]\n    )\n    fig = px.line_mapbox(\n        data[mask],\n        lat=\"latitude\",\n        lon=\"longitude\",\n        zoom=zoom,\n        center={\"lon\": center_lon, \"lat\": center_lat},\n        height=height,\n        width=width,\n    )\n    fig.update_traces(\n        line=dict(width=line_width),\n    )\n    fig.update_layout(\n        mapbox_style=map_style,\n        margin={\"r\": 57, \"t\": 0, \"l\": 49, \"b\": 0},\n    )\n\n    return fig\n</code></pre>"},{"location":"api_visualizations/#geo_track_analyzer.visualize.plot_track_enriched_on_map","title":"<code>plot_track_enriched_on_map(data, *, enrich_with_column='elevation', color_by_zone=False, zoom=13, height=None, width=None, overwrite_color_gradient=None, overwrite_unit_text=None, cbar_ticks=5, map_style='open-street-map', **kwargs)</code>","text":"<p>Plot the track line enriched with additional information (as z-axis) on a map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing track data.</p> required <code>enrich_with_column</code> <code>Literal['elevation', 'speed', 'heartrate', 'cadence', 'power']</code> <p>Column to enrich the track with, defaults to \"elevation\"</p> <code>'elevation'</code> <code>color_by_zone</code> <code>bool</code> <p>If True, track will be covered by Zones. Only available for enrich_with_column heartrate, cadence and power.</p> <code>False</code> <code>zoom</code> <code>int</code> <p>Zoom level for the map, defaults to 13</p> <code>13</code> <code>height</code> <code>None | int</code> <p>Height of the plot, defaults to None</p> <code>None</code> <code>width</code> <code>None | int</code> <p>Width of the plot, defaults to None</p> <code>None</code> <code>overwrite_color_gradient</code> <code>None | tuple[str, str]</code> <p>Custom color gradient for the plot. Check track_analyzer.visualize.constants for defaults, defaults to None</p> <code>None</code> <code>overwrite_unit_text</code> <code>None | str</code> <p>Custom unit text for the enrichment. Check track_analyzer.visualize.constants for defaults, defaults to None</p> <code>None</code> <code>cbar_ticks</code> <code>int</code> <p>Number of color bar ticks, defaults to 5</p> <code>5</code> <code>map_style</code> <code>str</code> <p>Valid map_style for plotly mapbox_style, defaults to open-street-map</p> <code>'open-street-map'</code> <code>kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object.</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>If no data is in passed enrich_with_column column</p> <code>VisualizationSetupError</code> <p>If color_by_zone is passed and enricht_with_column is unsupported or Zones are not set for the supported values</p> Source code in <code>geo_track_analyzer/visualize/map.py</code> <pre><code>def plot_track_enriched_on_map(\n    data: pd.DataFrame,\n    *,\n    enrich_with_column: Literal[\n        \"elevation\", \"speed\", \"heartrate\", \"cadence\", \"power\"\n    ] = \"elevation\",\n    color_by_zone: bool = False,\n    zoom: int = 13,\n    height: None | int = None,\n    width: None | int = None,\n    overwrite_color_gradient: None | tuple[str, str] = None,\n    overwrite_unit_text: None | str = None,\n    cbar_ticks: int = 5,\n    map_style: str = \"open-street-map\",\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"\n    Plot the track line enriched with additional information (as z-axis) on a map.\n\n    :param data: DataFrame containing track data.\n    :param enrich_with_column: Column to enrich the track with, defaults to \"elevation\"\n    :param color_by_zone: If True, track will be covered by Zones. Only available for\n        enrich_with_column heartrate, cadence and power.\n    :param zoom: Zoom level for the map, defaults to 13\n    :param height: Height of the plot, defaults to None\n    :param width: Width of the plot, defaults to None\n    :param overwrite_color_gradient: Custom color gradient for the plot. Check\n        track_analyzer.visualize.constants for defaults, defaults to None\n    :param overwrite_unit_text: Custom unit text for the enrichment. Check\n        track_analyzer.visualize.constants for defaults, defaults to None\n    :param cbar_ticks: Number of color bar ticks, defaults to 5\n    :param map_style: Valid map_style for plotly mapbox_style, defaults to\n        open-street-map\n    :param kwargs: Additional keyword arguments.\n    :raises VisualizationSetupError: If no data is in passed enrich_with_column column\n    :raises VisualizationSetupError: If color_by_zone is passed and enricht_with_column\n        is unsupported or Zones are not set for the supported values\n    :return: Plotly Figure object.\n    \"\"\"\n    if color_by_zone and (\n        (enrich_with_column not in [\"heartrate\", \"cadence\", \"power\"])\n        or (f\"{enrich_with_column}_zones\" not in data.columns)\n    ):\n        raise VisualizationSetupError(\"Zone data is not provided in passed dataframe\")\n\n    mask = data.moving\n\n    plot_data = data[mask]\n\n    center_lat, center_lon = center_geolocation(\n        [(r[\"latitude\"], r[\"longitude\"]) for r in data[mask].to_dict(\"records\")]\n    )\n\n    # ~~~~~~~~~~~~ Enrichment data ~~~~~~~~~~~~~~~~\n    enrich_unit = (\n        ENRICH_UNITS[enrich_with_column]\n        if overwrite_unit_text is None\n        else overwrite_unit_text\n    )\n    enrich_type = (\n        int if enrich_with_column in [\"heartrate\", \"cadence\", \"power\"] else float\n    )\n\n    # ~~~~~~~~~~~ Colors ~~~~~~~~~~~~~~~~~\n    color_column_values = plot_data[enrich_with_column]\n\n    if color_column_values.isna().all():\n        raise VisualizationSetupError(\n            f\"Plotting not possible. No values for {enrich_with_column} in passed data.\"\n        )\n\n    if color_column_values.isna().any():\n        logger.warning(\n            \"%s nan rows in %s. Dropping points\",\n            color_column_values.isna().sum(),\n            enrich_with_column,\n        )\n        plot_data = plot_data[~color_column_values.isna()]\n        color_column_values = color_column_values[~color_column_values.isna()]\n\n    if enrich_with_column == \"speed\":\n        color_column_values = color_column_values * 3.6\n    diff_abs = color_column_values.max() - color_column_values.min()\n    assert diff_abs &gt; 0\n\n    colorbar_trace = None\n    # ~~~~~~~~~~~~~~~~ Color by Zone ~~~~~~~~~~~~~~~~~~~~~~~\n    if color_by_zone:\n        color_col = f\"{enrich_with_column}_zone_colors\"\n        colors = plot_data[color_col]\n        marker = go.scattermapbox.Marker(color=colors)\n    # ~~~~~~~~~~~~~~~~ Generate color gradient from value ~~~~~~~~~~~~~~~\n    else:\n        if overwrite_color_gradient:\n            color_min, color_max = overwrite_color_gradient\n        else:\n            if enrich_with_column in COLOR_GRADIENTS.keys():\n                color_min, color_max = COLOR_GRADIENTS[enrich_with_column]\n            else:\n                color_min, color_max = DEFAULT_COLOR_GRADIENT\n        color_map = pd.Series(\n            data=get_color_gradient(color_min, color_max, round(diff_abs) + 1),\n            index=range(\n                round(color_column_values.min()), round(color_column_values.max()) + 1\n            ),\n        )\n\n        def color_mapper(value: float) -&gt; str:\n            if value &lt; color_map.index.start:\n                return color_map.iloc[0]\n            elif value &gt; color_map.index.stop:\n                return color_map.iloc[-1]\n            else:\n                return color_map.loc[int(value)]\n\n        colors = color_column_values.apply(color_mapper).to_list()\n        marker = go.scattermapbox.Marker(color=colors)\n\n        # ~~~~~~~~~~~~~~~ Colorbar for the passed column ~~~~~~~~~~~~~~~~~~~~\n        splits = 1 / (cbar_ticks - 1)\n        factor = 0.0\n        tick_vals = []\n        tick_cols = []\n        while factor &lt;= 1:\n            idx = int(diff_abs * factor)\n            tick_vals.append(color_map.index[idx])\n            tick_cols.append(color_map.iloc[idx])\n            factor += splits\n\n        colorbar_trace = go.Scatter(\n            x=[None],\n            y=[None],\n            mode=\"markers\",\n            marker=dict(\n                colorscale=color_map.to_list(),\n                showscale=True,\n                cmin=color_column_values.min(),\n                cmax=color_column_values.max(),\n                colorbar=dict(\n                    title=enrich_with_column.capitalize(),\n                    thickness=10,\n                    tickvals=tick_vals,\n                    ticktext=tick_vals,\n                    outlinewidth=0,\n                ),\n            ),\n            hoverinfo=\"none\",\n        )\n\n    # ~~~~~~~~~~~~~~~ Build figure ~~~~~~~~~~~~~~~~~~~\n    fig = go.Figure(\n        go.Scattermapbox(\n            lat=plot_data[\"latitude\"],\n            lon=plot_data[\"longitude\"],\n            mode=\"markers\",\n            marker=marker,\n            hovertemplate=f\"{enrich_with_column.capitalize()}: \"\n            + \"&lt;b&gt;%{text}&lt;/b&gt; \"\n            + f\"{enrich_unit} &lt;br&gt;\"\n            + \"&lt;b&gt;Lat&lt;/b&gt;: %{lat:4.6f}\u00b0&lt;br&gt;\"\n            + \"&lt;b&gt;Lon&lt;/b&gt;: %{lon:4.6f}\u00b0&lt;br&gt;\",\n            text=[enrich_type(v) for v in color_column_values.to_list()],\n            name=\"\",\n        )\n    )\n\n    if colorbar_trace is not None:\n        fig.add_trace(colorbar_trace)\n\n    fig.update_layout(mapbox_style=map_style)\n    fig.update_layout(\n        margin={\"r\": 57, \"t\": 5, \"l\": 49, \"b\": 5},\n        mapbox={\n            \"style\": map_style,\n            \"zoom\": zoom,\n            \"center\": {\"lon\": center_lon, \"lat\": center_lat},\n        },\n        height=height,\n        hovermode=\"closest\",\n        width=width,\n        showlegend=False,\n    )\n\n    return fig\n</code></pre>"},{"location":"api_visualizations/#geo_track_analyzer.visualize.plot_track_2d","title":"<code>plot_track_2d(data, *, include_velocity=False, include_heartrate=False, include_cadence=False, include_power=False, show_segment_borders=False, strict_data_selection=False, height=600, width=1800, pois=None, color_elevation=None, color_additional_trace=None, color_poi=None, color_segment_border=None, slider=False, split_by_zone=False, min_zone_size=0.0025, **kwargs)</code>","text":"<p>Elevation profile of the track. May be enhanced with additional information like Velocity, Heartrate, Cadence, and Power.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing track data</p> required <code>include_velocity</code> <code>bool</code> <p>Plot velocity as second y-axis, defaults to False</p> <code>False</code> <code>include_heartrate</code> <code>bool</code> <p>Plot heart rate as second y-axis, defaults to False</p> <code>False</code> <code>include_cadence</code> <code>bool</code> <p>Plot cadence as second y-axis, defaults to False</p> <code>False</code> <code>include_power</code> <code>bool</code> <p>Plot power as second y-axis, defaults to False</p> <code>False</code> <code>show_segment_borders</code> <code>bool</code> <p>If True show vertical lines between segments in track, defaults to False. If no segments are present in data, no error is raised.</p> <code>False</code> <code>strict_data_selection</code> <code>bool</code> <p>If True only included that passing the minimum speed requirements of the Track, defaults to False</p> <code>False</code> <code>height</code> <code>None | int</code> <p>Height of the plot, defaults to 600</p> <code>600</code> <code>width</code> <code>None | int</code> <p>Width of the plot, defaults to 1800</p> <code>1800</code> <code>pois</code> <code>None | list[tuple[float, float]]</code> <p>Optional lat/long coordingates to add to the plot as points of interest, defaults to None</p> <code>None</code> <code>color_elevation</code> <code>None | str</code> <p>Color of the elevation as str interpretable by plotly, defaults to None</p> <code>None</code> <code>color_additional_trace</code> <code>None | str</code> <p>Color of velocity/heartrate/cadence/power as str interpretable by plotly, defaults to None</p> <code>None</code> <code>color_poi</code> <code>None | str</code> <p>Color of the pois as str interpretable by plotly, defaults to None</p> <code>None</code> <code>color_segment_border</code> <code>None | str</code> <p>Color of the segment border lines as str interpretable by plotly, defaults to None</p> <code>None</code> <code>slider</code> <code>bool</code> <p>Should a slide be included in the plot to zoom into the x-axis, defaults to False</p> <code>False</code> <code>split_by_zone</code> <code>bool</code> <p>If True, and one for included_* flags is passed and Zones are set for the corresponding extension are set, the Zones will be colored according to the zone colors.</p> <code>False</code> <code>min_zone_size</code> <code>float</code> <p>Minimum fraction of points required for a distinct zone, if split_by_Zone is passed.</p> <code>0.0025</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object.</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>If more than one of include_velocity, include_heartrate, include_cadence, or include_power was set the True</p> <code>VisualizationSetupError</code> <p>If elevation data is missing in the data</p> <code>VisualizationSetupError</code> <p>If the data requried for the additional data is missing</p> <code>VisualizationSetupError</code> <p>If split_by_zone is passed but Zones are not set</p> Source code in <code>geo_track_analyzer/visualize/profiles.py</code> <pre><code>def plot_track_2d(\n    data: pd.DataFrame,\n    *,\n    include_velocity: bool = False,\n    include_heartrate: bool = False,\n    include_cadence: bool = False,\n    include_power: bool = False,\n    show_segment_borders: bool = False,\n    strict_data_selection: bool = False,\n    height: None | int = 600,\n    width: None | int = 1800,\n    pois: None | list[tuple[float, float]] = None,\n    color_elevation: None | str = None,\n    color_additional_trace: None | str = None,\n    color_poi: None | str = None,\n    color_segment_border: None | str = None,\n    slider: bool = False,\n    split_by_zone: bool = False,\n    min_zone_size: float = 0.0025,\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"Elevation profile of the track. May be enhanced with additional information like\n    Velocity, Heartrate, Cadence, and Power.\n\n    :param data: DataFrame containing track data\n    :param include_velocity: Plot velocity as second y-axis, defaults to False\n    :param include_heartrate: Plot heart rate as second y-axis, defaults to False\n    :param include_cadence: Plot cadence as second y-axis, defaults to False\n    :param include_power: Plot power as second y-axis, defaults to False\n    :param show_segment_borders: If True show vertical lines between segments in track,\n        defaults to False. If no segments are present in data, no error is raised.\n    :param strict_data_selection: If True only included that passing the minimum speed\n        requirements of the Track, defaults to False\n    :param height: Height of the plot, defaults to 600\n    :param width: Width of the plot, defaults to 1800\n    :param pois: Optional lat/long coordingates to add to the plot as points of\n        interest, defaults to None\n    :param color_elevation: Color of the elevation as str interpretable by plotly,\n        defaults to None\n    :param color_additional_trace: Color of velocity/heartrate/cadence/power as str\n        interpretable by plotly, defaults to None\n    :param color_poi: Color of the pois as str interpretable by plotly, defaults to None\n    :param color_segment_border: Color of the segment border lines as str interpretable\n        by plotly, defaults to None\n    :param slider: Should a slide be included in the plot to zoom into the x-axis,\n        defaults to False\n    :param split_by_zone: If True, and one for included_* flags is passed and Zones are\n        set for the corresponding extension are set, the Zones will be colored\n        according to the zone colors.\n    :param min_zone_size: Minimum fraction of points required for a distinct zone, if\n        split_by_Zone is passed.\n    :raises VisualizationSetupError: If more than one of include_velocity,\n        include_heartrate, include_cadence, or include_power was set the True\n    :raises VisualizationSetupError: If elevation data is missing in the data\n    :raises VisualizationSetupError: If the data requried for the additional data is\n       missing\n    :raises VisualizationSetupError: If split_by_zone is passed but Zones are not set\n\n    :return: Plotly Figure object.\n    \"\"\"\n    if split_by_zone:\n        color_additional_trace = None\n    if (\n        sum(\n            [\n                int(include_velocity),\n                int(include_heartrate),\n                int(include_cadence),\n                int(include_power),\n            ]\n        )\n        &gt; 1\n    ):\n        raise VisualizationSetupError(\n            \"Only one of include_velocity, include_heartrate, include_cadence, \"\n            \"and include_power can be set to True\"\n        )\n    mask = data.moving\n    if strict_data_selection:\n        mask = mask &amp; data.in_speed_percentile\n\n    data_for_plot: pd.DataFrame = data[mask].copy()  # type: ignore\n\n    if show_segment_borders:\n        show_segment_borders = _check_segment_availability(data_for_plot)\n\n    if data_for_plot.elevation.isna().all():\n        raise VisualizationSetupError(\"Can not plot profile w/o elevation information\")\n\n    fig = make_subplots(specs=[[{\"secondary_y\": True}]])\n    fig.add_trace(\n        go.Scatter(\n            x=data_for_plot.cum_distance_moving,\n            y=data_for_plot.elevation,\n            mode=\"lines\",\n            name=\"Elevation [m]\",\n            fill=\"tozeroy\",\n            text=[\n                \"&lt;b&gt;Lat&lt;/b&gt;: {lat:4.6f}\u00b0&lt;br&gt;&lt;b&gt;Lon&lt;/b&gt;: {lon:4.6f}\u00b0&lt;br&gt;\".format(\n                    lon=rcrd[\"longitude\"], lat=rcrd[\"latitude\"]\n                )\n                for rcrd in data_for_plot.to_dict(\"records\")\n            ],\n            hovertemplate=\"&lt;b&gt;Distance&lt;/b&gt;: %{x:.1f} km &lt;br&gt;&lt;b&gt;Elevation&lt;/b&gt;: \"\n            + \"%{y:.1f} m &lt;br&gt;%{text}&lt;extra&gt;&lt;/extra&gt;\",\n            showlegend=False,\n        ),\n        secondary_y=False,\n    )\n    fig.update_yaxes(\n        title_text=\"Elevation [m]\",\n        secondary_y=False,\n        range=[\n            data_for_plot.elevation.min() * 0.97,\n            data_for_plot.elevation.max() * 1.05,\n        ],\n    )\n    fig.update_xaxes(title_text=\"Distance [m]\")\n\n    secondary = None\n    if include_velocity:\n        secondary = \"velocity\"\n    if include_heartrate:\n        secondary = \"heartrate\"\n    if include_cadence:\n        secondary = \"cadence\"\n    if include_power:\n        secondary = \"power\"\n\n    if secondary is not None:\n        _add_secondary(\n            fig=fig,\n            data=data_for_plot,\n            secondary=secondary,\n            split_by_zone=split_by_zone,\n            min_zone_size=min_zone_size,\n        )\n\n    if pois is not None:\n        for i_poi, poi in enumerate(pois):\n            lat, lng = poi\n            poi_data = data_for_plot[\n                (data_for_plot.latitude == lat) &amp; (data_for_plot.longitude == lng)\n            ]\n            if poi_data.empty:\n                logger.warning(\"Could not find POI in data. Skipping\")\n                continue\n            poi_x = poi_data.iloc[0].cum_distance_moving\n            poi_y = poi_data.iloc[0].elevation\n\n            fig.add_scatter(\n                name=f\"PIO {i_poi} @ {lat} / {lng}\",\n                x=[poi_x],\n                y=[poi_y],\n                mode=\"markers\",\n                marker=dict(\n                    size=20,\n                    color=\"MediumPurple\" if color_poi is None else color_poi,\n                    symbol=\"triangle-up\",\n                    standoff=10,\n                    angle=180,\n                ),\n                showlegend=False,\n            )\n\n    if show_segment_borders:\n        _add_segment_borders(data_for_plot, fig, color_segment_border)\n\n    fig.update_layout(\n        showlegend=split_by_zone,\n        autosize=False,\n        margin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0},\n    )\n    if height is not None:\n        fig.update_layout(height=height)\n    if width is not None:\n        fig.update_layout(width=width)\n\n    fig.update_xaxes(\n        range=[\n            data_for_plot.iloc[0].cum_distance_moving,\n            data_for_plot.iloc[-1].cum_distance_moving,\n        ]\n    )\n\n    if slider:\n        fig.update_layout(\n            xaxis=dict(\n                rangeslider=dict(visible=True),\n            )\n        )\n\n    if color_elevation is not None:\n        fig.data[0].marker.color = color_elevation  # type: ignore\n    if color_additional_trace is not None and any(\n        [include_velocity, include_heartrate, include_cadence, include_power]\n    ):\n        fig.data[1].marker.color = color_additional_trace  # type: ignore\n\n    return fig\n</code></pre>"},{"location":"api_visualizations/#track-profile","title":"Track profile","text":""},{"location":"api_visualizations/#geo_track_analyzer.visualize.plot_track_with_slope","title":"<code>plot_track_with_slope(data, *, slope_gradient_color=('#0000FF', '#00FF00', '#FF0000'), min_slope=-18, max_slope=18, show_segment_borders=False, height=600, width=1800, slider=False, color_segment_border=None, **kwargs)</code>","text":"<p>Elevation profile with slopes between points.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing track data</p> required <code>slope_gradient_color</code> <code>tuple[str, str, str]</code> <p>Colors for the min, neutral, max slope values, defaults to (\"#0000FF\", \"#00FF00\", \"#FF0000\")</p> <code>('#0000FF', '#00FF00', '#FF0000')</code> <code>min_slope</code> <code>int</code> <p>Minimum slope for the gradient also acts as floor for the displayed slope, defaults to -18</p> <code>-18</code> <code>max_slope</code> <code>int</code> <p>Maximum  slope for the gradient also acts as ceiling for the displayed slope, defaults to 18</p> <code>18</code> <code>show_segment_borders</code> <code>bool</code> <p>If True show vertical lines between segments in track, defaults to False. If no segments are present in data, no error is raised.</p> <code>False</code> <code>height</code> <code>None | int</code> <p>Height of the plot, defaults to 600</p> <code>600</code> <code>width</code> <code>None | int</code> <p>Width of the plot, defaults to 1800</p> <code>1800</code> <code>slider</code> <code>bool</code> <p>Should a slide be included in the plot to zoom into the x-axis, defaults to False</p> <code>False</code> <code>color_segment_border</code> <code>None | str</code> <p>Color of the segment border lines as str interpretable by plotly, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>If elevation data is missing in the data</p> Source code in <code>geo_track_analyzer/visualize/profiles.py</code> <pre><code>def plot_track_with_slope(\n    data: pd.DataFrame,\n    *,\n    slope_gradient_color: tuple[str, str, str] = (\"#0000FF\", \"#00FF00\", \"#FF0000\"),\n    min_slope: int = -18,\n    max_slope: int = 18,\n    show_segment_borders: bool = False,\n    height: None | int = 600,\n    width: None | int = 1800,\n    slider: bool = False,\n    color_segment_border: None | str = None,\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"Elevation profile with slopes between points.\n\n    :param data: DataFrame containing track data\n    :param slope_gradient_color: Colors for the min, neutral, max slope values,\n        defaults to (\"#0000FF\", \"#00FF00\", \"#FF0000\")\n    :param min_slope: Minimum slope for the gradient also acts as floor for the\n        displayed slope, defaults to -18\n    :param max_slope: Maximum  slope for the gradient also acts as ceiling for the\n        displayed slope, defaults to 18\n    :param show_segment_borders: If True show vertical lines between segments in track,\n        defaults to False. If no segments are present in data, no error is raised.\n    :param height: Height of the plot, defaults to 600\n    :param width: Width of the plot, defaults to 1800\n    :param slider: Should a slide be included in the plot to zoom into the x-axis,\n        defaults to False\n    :param color_segment_border: Color of the segment border lines as str interpretable\n        by plotly, defaults to None\n    :raises VisualizationSetupError: If elevation data is missing in the data\n\n    :return: Plotly Figure object\n    \"\"\"\n    slope_color_map = get_slope_colors(\n        *slope_gradient_color, max_slope=max_slope, min_slope=min_slope\n    )\n\n    data = data[data.moving].copy()  # type: ignore\n\n    if data.elevation.isna().all():\n        raise VisualizationSetupError(\"Can not plot profile w/o elevation information\")\n\n    if show_segment_borders:\n        show_segment_borders = _check_segment_availability(data)\n\n    elevations = data.elevation.to_list()\n    diff_elevation = [0]\n    for i, elevation in enumerate(elevations[1:]):\n        diff_elevation.append(elevation - elevations[i])\n\n    data[\"elevation_diff\"] = diff_elevation\n\n    def calc_slope(row: pd.Series) -&gt; int:\n        try:\n            slope = round((row.elevation_diff / row.distance) * 100)\n        except ZeroDivisionError:\n            slope = 0\n\n        if slope &gt; max_slope:\n            slope = max_slope\n        elif slope &lt; min_slope:\n            slope = min_slope\n\n        return slope\n\n    data[\"slope\"] = data.apply(lambda row: calc_slope(row), axis=1).astype(int)\n\n    fig = go.Figure()\n\n    fig.add_trace(\n        go.Scatter(\n            x=data.cum_distance_moving,\n            y=data.elevation,\n            mode=\"lines\",\n            name=\"Elevation [m]\",\n            fill=\"tozeroy\",\n        )\n    )\n\n    if slider:\n        fig.update_layout(\n            xaxis=dict(\n                rangeslider=dict(visible=True),\n            )\n        )\n\n    for i in range(len(data)):\n        this_data = data.iloc[i : i + 2]\n        if len(this_data) == 1:\n            continue\n\n        slope_val = this_data.iloc[1].slope\n\n        color = slope_color_map[slope_val]\n        max_distance: float = max(this_data.cum_distance_moving)\n        fig.add_trace(\n            go.Scatter(\n                x=this_data.cum_distance_moving,\n                y=this_data.elevation,\n                mode=\"lines\",\n                name=f\"Distance {max_distance/1000:.1f} km\",\n                fill=\"tozeroy\",\n                marker_color=color,\n                hovertemplate=f\"Slope: {slope_val} %\",\n            )\n        )\n\n    if show_segment_borders:\n        _add_segment_borders(data, fig, color_segment_border)\n\n    fig.update_layout(\n        showlegend=False, autosize=False, margin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0}\n    )\n\n    if height is not None:\n        fig.update_layout(height=height)\n    if width is not None:\n        fig.update_layout(width=width)\n\n    min_elevation: float = min(data.elevation)\n    max_elevation: float = max(data.elevation)\n    fig.update_yaxes(\n        showspikes=True,\n        spikemode=\"across\",\n        range=[min_elevation * 0.95, max_elevation * 1.05],\n        title_text=\"Elevation [m]\",\n    )\n    fig.update_xaxes(title_text=\"Distance [m]\")\n\n    return fig\n</code></pre>"},{"location":"api_visualizations/#geo_track_analyzer.visualize.plot_segments_on_map","title":"<code>plot_segments_on_map(data, *, zoom=13, height=None, width=None, line_width=2.5, average_only=True, map_style='open-street-map', **kwargs)</code>","text":"<p>Plot track line on map. Segments are displayed individually.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing track segment data.</p> required <code>zoom</code> <code>int</code> <p>Zoom level for the map, defaults to 13</p> <code>13</code> <code>height</code> <code>None | int</code> <p>Height of the plot, defaults to None</p> <code>None</code> <code>width</code> <code>None | int</code> <p>Width of the plot, defaults to None</p> <code>None</code> <code>line_width</code> <code>float</code> <p>Width of the line on the map, defaults to 2.5</p> <code>2.5</code> <code>average_only</code> <code>bool</code> <p>Flag to display averages only, defaults to True</p> <code>True</code> <code>map_style</code> <code>str</code> <p>Valid map_style for plotly mapbox_style, defaults to open-street-map</p> <code>'open-street-map'</code> <code>kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object.</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>If no segment information is contained in the data</p> <code>VisualizationSetupError</code> <p>If there are not two or more segments in the data</p> Source code in <code>geo_track_analyzer/visualize/map.py</code> <pre><code>def plot_segments_on_map(\n    data: pd.DataFrame,\n    *,\n    zoom: int = 13,\n    height: None | int = None,\n    width: None | int = None,\n    line_width: float = 2.5,\n    average_only: bool = True,\n    map_style: str = \"open-street-map\",\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"\n    Plot track line on map. Segments are displayed individually.\n\n    :param data: DataFrame containing track segment data.\n    :param zoom: Zoom level for the map, defaults to 13\n    :param height: Height of the plot, defaults to None\n    :param width: Width of the plot, defaults to None\n    :param line_width: Width of the line on the map, defaults to 2.5\n    :param average_only: Flag to display averages only, defaults to True\n    :param map_style: Valid map_style for plotly mapbox_style, defaults to\n        open-street-map\n    :param kwargs: Additional keyword arguments.\n    :raises VisualizationSetupError: If no segment information is contained in the data\n    :raises VisualizationSetupError: If there are not two or more segments in the data\n\n    :return: Plotly Figure object.\n    \"\"\"\n    mask = data.moving\n\n    plot_data = data[mask]\n\n    if \"segment\" not in plot_data.columns:\n        raise VisualizationSetupError(\n            \"Data has no **segment** in columns. Required for plot\"\n        )\n    if len(plot_data.segment.unique()) &lt; 2:\n        raise VisualizationSetupError(\"Data does not have mulitple segments\")\n\n    center_lat, center_lon = center_geolocation(\n        [(r[\"latitude\"], r[\"longitude\"]) for r in data[mask].to_dict(\"records\")]\n    )\n\n    fig = go.Figure()\n    for i_segment, frame in plot_data.groupby(by=\"segment\"):\n        mean_heartrate = frame.heartrate.agg(\"mean\")\n        min_heartrate = frame.heartrate.agg(\"min\")\n        max_heartrate = frame.heartrate.agg(\"max\")\n\n        mean_speed = frame.speed.agg(\"mean\") * 3.6\n        min_speed = frame.speed.agg(\"min\") * 3.6\n        max_speed = frame.speed.agg(\"max\") * 3.6\n\n        mean_power = frame.power.agg(\"mean\")\n        min_power = frame.power.agg(\"min\")\n        max_power = frame.power.agg(\"max\")\n\n        distance = frame.distance.sum() / 1000\n        if frame.time.isna().all():\n            total_time = None\n        else:\n            _total_time = frame.time.sum()  # in seconds\n            total_time = timedelta(seconds=int(_total_time.astype(int)))\n        min_elevation = frame.elevation.min()\n        max_elevation = frame.elevation.max()\n\n        text: str = (\n            f\"&lt;b&gt;Segment {i_segment}&lt;/b&gt;&lt;br&gt;\"\n            + f\"&lt;b&gt;Distance&lt;/b&gt;: {distance:.2f} km&lt;br&gt;\"\n        )\n        if total_time is not None:\n            text += f\"&lt;b&gt;Time&lt;/b&gt;: {format_timedelta(total_time)}&lt;br&gt;\"\n\n        text += (\n            f\"&lt;b&gt;Elevation&lt;/b&gt;: &amp;#8600; {min_elevation} m \"\n            + f\"&amp;#8599; {max_elevation} m&lt;br&gt;\"\n        )\n        if not np.isnan(mean_speed):\n            text += f\"&lt;b&gt;Speed&lt;/b&gt;: &amp;#248; {mean_speed:.1f} \"\n            if not average_only:\n                text += f\" &amp;#8600;{min_speed:.1f} &amp;#8599;{max_speed:.1f} km/h &lt;br&gt;\"\n            text += \" km/h &lt;br&gt;\"\n        if not np.isnan(mean_heartrate):\n            text += f\"&lt;b&gt;Heartrate&lt;/b&gt;: &amp;#248; {int(mean_heartrate)} \"\n            if not average_only:\n                text += f\"&amp;#8600;{int(min_heartrate)} &amp;#8599;{int(max_heartrate)}&lt;br&gt;\"\n            text += \" bpm&lt;br&gt;\"\n        if not np.isnan(mean_power):\n            text += f\"&lt;b&gt;Power&lt;/b&gt;: &amp;#248; {mean_power:.1f} \"\n            if not average_only:\n                text += f\"&amp;#8600;{min_power:.1f} &amp;#8599;{max_power:.1f}&lt;br&gt;\"\n            text += \" W&lt;br&gt;\"\n\n        fig.add_trace(\n            go.Scattermapbox(\n                lat=frame[\"latitude\"],\n                lon=frame[\"longitude\"],\n                mode=\"lines\",\n                hovertemplate=\"%{text} \",\n                text=len(frame) * [text],\n                line=dict(width=line_width),\n                name=\"\",\n            )\n        )\n\n    fig.update_layout(\n        margin={\"r\": 57, \"t\": 5, \"l\": 49, \"b\": 5},\n        mapbox={\n            \"style\": map_style,\n            \"zoom\": zoom,\n            \"center\": {\"lon\": center_lon, \"lat\": center_lat},\n        },\n        height=height,\n        hovermode=\"closest\",\n        width=width,\n        showlegend=False,\n    )\n\n    return fig\n</code></pre>"},{"location":"api_visualizations/#other-track-visualizations","title":"Other track visualizations","text":""},{"location":"api_visualizations/#geo_track_analyzer.visualize.plot_track_3d","title":"<code>plot_track_3d(data, strict_data_selection=False)</code>","text":"Source code in <code>geo_track_analyzer/visualize/interactive.py</code> <pre><code>def plot_track_3d(data: pd.DataFrame, strict_data_selection: bool = False) -&gt; Figure:\n    mask = data.moving\n    if strict_data_selection:\n        mask = mask &amp; data.in_speed_percentile\n\n    data_for_plot = data[mask]\n\n    return px.line_3d(data_for_plot, x=\"latitude\", y=\"longitude\", z=\"elevation\")\n</code></pre>"},{"location":"api_visualizations/#summary-visualizations","title":"Summary visualizations","text":""},{"location":"api_visualizations/#geo_track_analyzer.visualize.plot_track_zones","title":"<code>plot_track_zones(data, metric, aggregate, *, use_zone_colors=False, height=600, width=1200, strict_data_selection=False)</code>","text":"<p>Aggregate a value per zone defined for heartrate, power, or cadence.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing track and zone data</p> required <code>metric</code> <code>Literal['heartrate', 'power', 'cadence']</code> <p>One of \"heartrate\", \"cadence\", or \"power\"</p> required <code>aggregate</code> <code>Literal['time', 'distance', 'speed']</code> <p>Value to aggregate. Supported values are (total) \"time\", \"distance\",  and (average) speed in a certain zone</p> required <code>use_zone_colors</code> <code>bool</code> <p>If True, use distinct colors per zone (either set by the zone object or a default defined by the package). Otherwise alternating colors will be used, defaults to False.</p> <code>False</code> <code>height</code> <code>None | int</code> <p>Height of the plot, defaults to 600</p> <code>600</code> <code>width</code> <code>None | int</code> <p>Width of the plot, defaults to 1200</p> <code>1200</code> <code>strict_data_selection</code> <code>bool</code> <p>If True only included that passing the minimum speed requirements of the Track, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>Is raised if metric is not avaialable in the data</p> Source code in <code>geo_track_analyzer/visualize/summary.py</code> <pre><code>def plot_track_zones(\n    data: pd.DataFrame,\n    metric: Literal[\"heartrate\", \"power\", \"cadence\"],\n    aggregate: Literal[\"time\", \"distance\", \"speed\"],\n    *,\n    use_zone_colors: bool = False,\n    height: None | int = 600,\n    width: None | int = 1200,\n    strict_data_selection: bool = False,\n) -&gt; Figure:\n    \"\"\"Aggregate a value per zone defined for heartrate, power, or cadence.\n\n    :param data: DataFrame containing track and zone data\n    :param metric: One of \"heartrate\", \"cadence\", or \"power\"\n    :param aggregate: Value to aggregate. Supported values are (total) \"time\",\n        \"distance\",  and (average) speed in a certain zone\n    :param use_zone_colors: If True, use distinct colors per zone (either set by the\n        zone object or a default defined by the package). Otherwise alternating colors\n        will be used, defaults to False.\n    :param height: Height of the plot, defaults to 600\n    :param width: Width of the plot, defaults to 1200\n    :param strict_data_selection: If True only included that passing the minimum speed\n        requirements of the Track, defaults to False\n    :raises VisualizationSetupError: Is raised if metric is not avaialable in the data\n\n    :return: Plotly Figure object\n    \"\"\"\n    data_for_plot = _preprocess_data(data, metric, strict_data_selection)\n\n    bin_data, y_title, tickformat = _aggregate_zone_data(\n        data_for_plot,\n        metric,\n        aggregate,\n        aggregation_method=\"mean\" if aggregate == \"speed\" else \"sum\",\n    )\n\n    if use_zone_colors:\n        colors = bin_data.colors\n    else:\n        col_a, col_b = DEFAULT_BAR_COLORS\n        colors = []\n        for i in range(len(bin_data)):\n            colors.append(col_a if i % 2 == 0 else col_b)\n\n    fig = go.Figure(\n        go.Bar(\n            x=bin_data[f\"{metric}_zones\"],\n            y=bin_data[aggregate],\n            marker_color=colors,\n            hoverinfo=\"skip\",\n        ),\n    )\n\n    for i, rcrd in enumerate(bin_data.to_dict(\"records\")):\n        kwargs: dict[str, Any] = dict(\n            x=i,\n            showarrow=False,\n            yshift=10,\n        )\n        if aggregate == \"time\":\n            kwargs.update(\n                dict(\n                    y=rcrd[\"time\"],\n                    text=rcrd[\"time\"].time().isoformat(),\n                )\n            )\n        elif aggregate == \"distance\":\n            kwargs.update(\n                dict(\n                    y=rcrd[\"distance\"],\n                    text=f\"{rcrd['distance']:.2f} km\",\n                )\n            )\n        elif aggregate == \"speed\":\n            kwargs.update(\n                dict(\n                    y=rcrd[\"speed\"],\n                    text=f\"{rcrd['speed']:.2f} km/h\",\n                )\n            )\n        else:\n            raise NotImplementedError(f\"Aggregate {aggregate} is not implemented\")\n\n        fig.add_annotation(**kwargs)\n\n    fig.update_layout(\n        title=f\"{aggregate.capitalize()} in {metric.capitalize()} zones\",\n        yaxis=dict(tickformat=tickformat, title=y_title),\n        bargap=0.0,\n    )\n\n    if height is not None:\n        fig.update_layout(height=height)\n    if width is not None:\n        fig.update_layout(width=width)\n\n    return fig\n</code></pre>"},{"location":"api_visualizations/#geo_track_analyzer.visualize.plot_segment_zones","title":"<code>plot_segment_zones(data, metric, aggregate, *, bar_colors=None, height=600, width=1200, strict_data_selection=False)</code>","text":"<p>Aggregate a value per zone defined for heartrate, power, or cadence, split into segments available in data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing track and zone data</p> required <code>metric</code> <code>Literal['heartrate', 'power', 'cadence']</code> <p>One of heartrate, cadence, or power</p> required <code>aggregate</code> <code>Literal['time', 'distance', 'speed']</code> <p>Value to aggregate. Supported values are (total) \"time\", \"distance\",  and (average) speed in a certain zone</p> required <code>bar_colors</code> <code>None | tuple[str, str] | list[str]</code> <p>Overwrite the default colors for the bar. If a tuple of two colors is passed, a colorscale will be generated based on these values and colors for segments will be picked from this scale. Furthermore, a list of colors can be passed that must at least be as long as the number of segments in the data</p> <code>None</code> <code>height</code> <code>None | int</code> <p>Height of the plot, defaults to 600</p> <code>600</code> <code>width</code> <code>None | int</code> <p>Width of the plot, defaults to 1200</p> <code>1200</code> <code>strict_data_selection</code> <code>bool</code> <p>If True only included that passing the minimum speed requirements of the Track, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>Is raised if metric is not avaialable in the data</p> <code>VisualizationSetupError</code> <p>Is raised if no segment information is available in the data</p> Source code in <code>geo_track_analyzer/visualize/summary.py</code> <pre><code>def plot_segment_zones(\n    data: pd.DataFrame,\n    metric: Literal[\"heartrate\", \"power\", \"cadence\"],\n    aggregate: Literal[\"time\", \"distance\", \"speed\"],\n    *,\n    bar_colors: None | tuple[str, str] | list[str] = None,\n    height: None | int = 600,\n    width: None | int = 1200,\n    strict_data_selection: bool = False,\n) -&gt; Figure:\n    \"\"\"Aggregate a value per zone defined for heartrate, power, or cadence, split into\n    segments available in data.\n\n    :param data: DataFrame containing track and zone data\n    :param metric: One of heartrate, cadence, or power\n    :param aggregate: Value to aggregate. Supported values are (total) \"time\",\n        \"distance\",  and (average) speed in a certain zone\n    :param bar_colors: Overwrite the default colors for the bar. If a tuple of two\n        colors is passed, a colorscale will be generated based on these values and\n        colors for segments will be picked from this scale. Furthermore, a list of\n        colors can be passed that must at least be as long as the number of segments in\n        the data\n    :param height: Height of the plot, defaults to 600\n    :param width: Width of the plot, defaults to 1200\n    :param strict_data_selection: If True only included that passing the minimum speed\n        requirements of the Track, defaults to False\n    :raises VisualizationSetupError: Is raised if metric is not avaialable in the data\n    :raises VisualizationSetupError: Is raised if no segment information is available in\n        the data\n\n    :return: Plotly Figure object\n    \"\"\"\n    if \"segment\" not in data.columns:\n        raise VisualizationSetupError(\n            \"Data has no **segment** in columns. Required for plot\"\n        )\n    data_for_plot = _preprocess_data(data, metric, strict_data_selection)\n\n    fig = go.Figure()\n\n    plot_segments = data_for_plot.segment.unique()\n\n    if isinstance(bar_colors, list):\n        if len(plot_segments) &gt; len(bar_colors):\n            raise VisualizationSetupError(\n                \"If a list of colors is passed, it must be at least same lenght as the \"\n                \"segments in the data\"\n            )\n        colors = bar_colors[0 : len(plot_segments)]\n    else:\n        colors = sample_colorscale(\n            make_colorscale(DEFAULT_BAR_COLORS if bar_colors is None else bar_colors),\n            len(plot_segments),\n        )\n\n    for color, segment in zip(colors, plot_segments):\n        _data_for_plot = data_for_plot[data_for_plot.segment == segment]\n        bin_data, y_title, tickformat = _aggregate_zone_data(\n            _data_for_plot,\n            metric,\n            aggregate,\n            aggregation_method=\"mean\" if aggregate == \"speed\" else \"sum\",\n        )\n\n        hovertext = []\n        for rcrd in bin_data.to_dict(\"records\"):\n            if aggregate == \"time\":\n                hovertext.append(rcrd[\"time\"].time().isoformat())\n\n            elif aggregate == \"distance\":\n                hovertext.append(f\"{rcrd['distance']:.2f} km\")\n\n            elif aggregate == \"speed\":\n                hovertext.append(f\"{rcrd['speed']:.2f} km/h\")\n\n        fig.add_trace(\n            go.Bar(\n                x=bin_data[f\"{metric}_zones\"],\n                y=bin_data[aggregate],\n                name=f\"Segment {segment}\",\n                marker_color=color,\n                hovertext=hovertext,\n                hovertemplate=\"%{hovertext}&lt;extra&gt;&lt;/extra&gt;\",\n            ),\n        )\n\n    fig.update_layout(\n        title=f\"{aggregate.capitalize()} in {metric.capitalize()} zones\",\n        yaxis=dict(tickformat=tickformat, title=y_title),\n    )\n\n    if height is not None:\n        fig.update_layout(height=height)\n    if width is not None:\n        fig.update_layout(width=width)\n\n    return fig\n</code></pre>"},{"location":"api_visualizations/#geo_track_analyzer.visualize.plot_segment_summary","title":"<code>plot_segment_summary(data, aggregate, *, colors=None, height=600, width=1200, strict_data_selection=False)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing track and zone data</p> required <code>aggregate</code> <code>Literal['total_time', 'total_distance', 'avg_speed', 'max_speed']</code> <p>Value to aggregate. Supported values are \"total_time\", \"total_distance\", \"avg_speed\", and \"max_speed\"</p> required <code>colors</code> <code>None | tuple[str, str]</code> <p>Overwrite the default alternating colors, defaults to None</p> <code>None</code> <code>height</code> <code>None | int</code> <p>Height of the plot, defaults to 600</p> <code>600</code> <code>width</code> <code>None | int</code> <p>Width of the plot, defaults to 1200</p> <code>1200</code> <code>strict_data_selection</code> <code>bool</code> <p>If True only included that passing the minimum speed requirements of the Track, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>Is raised if no segment information is available in the data</p> Source code in <code>geo_track_analyzer/visualize/summary.py</code> <pre><code>def plot_segment_summary(\n    data: pd.DataFrame,\n    aggregate: Literal[\"total_time\", \"total_distance\", \"avg_speed\", \"max_speed\"],\n    *,\n    colors: None | tuple[str, str] = None,\n    height: None | int = 600,\n    width: None | int = 1200,\n    strict_data_selection: bool = False,\n) -&gt; Figure:\n    \"\"\"_summary_\n\n    :param data: DataFrame containing track and zone data\n    :param aggregate: Value to aggregate. Supported values are \"total_time\",\n        \"total_distance\", \"avg_speed\", and \"max_speed\"\n    :param colors: Overwrite the default alternating colors, defaults to None\n    :param height: Height of the plot, defaults to 600\n    :param width: Width of the plot, defaults to 1200\n    :param strict_data_selection: If True only included that passing the minimum speed\n        requirements of the Track, defaults to False\n    :raises VisualizationSetupError: Is raised if no segment information is available in\n        the data\n\n    :return: Plotly Figure object\n    \"\"\"\n    if \"segment\" not in data.columns:\n        raise VisualizationSetupError(\n            \"Data has no **segment** in columns. Required for plot\"\n        )\n\n    if colors is None:\n        colors = DEFAULT_BAR_COLORS\n    col_a, col_b = colors\n\n    mask = data.moving\n    if strict_data_selection:\n        mask = mask &amp; data.in_speed_percentile\n\n    _data_for_plot = data[mask]\n\n    fig = go.Figure()\n\n    if aggregate == \"avg_speed\":\n        bin_data = _data_for_plot.groupby(\"segment\").speed.agg(\"mean\") * 3.6\n        y_title = \"Average velocity [km/h]\"\n        tickformat = \"\"\n        hover_map_func = lambda v: str(f\"{v:.2f} km/h\")\n    elif aggregate == \"max_speed\":\n        bin_data = _data_for_plot.groupby(\"segment\").speed.agg(\"max\") * 3.6\n        y_title = \"Maximum velocity [km/h]\"\n        tickformat = \"\"\n        hover_map_func = lambda v: str(f\"{v:.2f} km/h\")\n    elif aggregate == \"total_distance\":\n        bin_data = _data_for_plot.groupby(\"segment\").distance.agg(\"sum\") / 1000\n        y_title = \"Distance [km]\"\n        tickformat = \"\"\n        hover_map_func = lambda v: str(f\"{v:.2f} km\")\n    elif aggregate == \"total_time\":\n        bin_data = pd.to_datetime(\n            _data_for_plot.groupby(\"segment\").time.agg(\"sum\"), unit=\"s\"\n        )\n        y_title = \"Duration\"\n        tickformat = \"%H:%M:%S\"\n        hover_map_func = lambda dt: str(dt.time())\n    else:\n        raise NotImplementedError(f\"Aggregate {aggregate} is not implemented\")\n\n    fig.add_trace(\n        go.Bar(\n            x=[f\"Segment {idx}\" for idx in bin_data.index.to_list()],\n            y=bin_data.to_list(),\n            marker_color=[col_a if i % 2 == 0 else col_b for i in range(len(bin_data))],\n            hovertext=list(map(hover_map_func, bin_data.to_list())),\n            hovertemplate=\"%{hovertext}&lt;extra&gt;&lt;/extra&gt;\",\n        ),\n    )\n\n    fig.update_layout(\n        yaxis=dict(tickformat=tickformat, title=y_title),\n        bargap=0.0,\n    )\n\n    if height is not None:\n        fig.update_layout(height=height)\n    if width is not None:\n        fig.update_layout(width=width)\n\n    return fig\n</code></pre>"},{"location":"api_visualizations/#geo_track_analyzer.visualize.plot_segment_box_summary","title":"<code>plot_segment_box_summary(data, metric, *, colors=None, height=600, width=1200, strict_data_selection=False)</code>","text":"<p>Show the metric as boxplot for each segment in the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing track and zone data</p> required <code>metric</code> <code>Literal['heartrate', 'power', 'cadence', 'speed', 'elevation']</code> <p>One of \"heartrate\", \"cadence\", \"power\", or \"speed\"</p> required <code>colors</code> <code>None | tuple[str, str]</code> <p>Overwrite the default alternating colors, defaults to None</p> <code>None</code> <code>height</code> <code>None | int</code> <p>Height of the plot, defaults to 600</p> <code>600</code> <code>width</code> <code>None | int</code> <p>Width of the plot, defaults to 1200</p> <code>1200</code> <code>strict_data_selection</code> <code>bool</code> <p>If True only included that passing the minimum speed requirements of the Track, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object</p> <p>Raises:</p> Type Description <code>VisualizationSetupError</code> <p>Is raised if metric is not avaialable in the data</p> <code>VisualizationSetupError</code> <p>Is raised if no segment information is available in the data</p> Source code in <code>geo_track_analyzer/visualize/summary.py</code> <pre><code>def plot_segment_box_summary(\n    data: pd.DataFrame,\n    metric: Literal[\"heartrate\", \"power\", \"cadence\", \"speed\", \"elevation\"],\n    *,\n    colors: None | tuple[str, str] = None,\n    height: None | int = 600,\n    width: None | int = 1200,\n    strict_data_selection: bool = False,\n) -&gt; Figure:\n    \"\"\"Show the metric as boxplot for each segment in the data.\n\n    :param data: DataFrame containing track and zone data\n    :param metric: One of \"heartrate\", \"cadence\", \"power\", or \"speed\"\n    :param colors: Overwrite the default alternating colors, defaults to None\n    :param height: Height of the plot, defaults to 600\n    :param width: Width of the plot, defaults to 1200\n    :param strict_data_selection: If True only included that passing the minimum speed\n        requirements of the Track, defaults to False\n    :raises VisualizationSetupError: Is raised if metric is not avaialable in the data\n    :raises VisualizationSetupError: Is raised if no segment information is available in\n        the data\n\n    :return: Plotly Figure object\n    \"\"\"\n    if \"segment\" not in data.columns:\n        raise VisualizationSetupError(\n            \"Data has no **segment** in columns. Required for plot\"\n        )\n\n    if metric not in data.columns:\n        raise VisualizationSetupError(\"Metric %s not part of the passed data\" % metric)\n\n    if colors is None:\n        colors = DEFAULT_BAR_COLORS\n    col_a, col_b = colors\n\n    mask = data.moving\n    if strict_data_selection:\n        mask = mask &amp; data.in_speed_percentile\n\n    data_for_plot = data[mask]\n\n    fig = go.Figure()\n\n    for i, segment in enumerate(data_for_plot.segment.unique()):\n        _data_for_plot = data_for_plot[data_for_plot.segment == segment]\n\n        if metric == \"speed\":\n            box_data = _data_for_plot[\"speed\"] * 3.6\n        else:\n            box_data = _data_for_plot[metric]\n\n        fig.add_trace(\n            go.Box(\n                y=box_data,\n                name=f\"Segment {segment}\",\n                boxpoints=False,\n                line_color=col_a if i % 2 == 0 else col_b,\n                marker_color=col_a if i % 2 == 0 else col_b,\n            )\n        )\n    if height is not None:\n        fig.update_layout(height=height)\n    if width is not None:\n        fig.update_layout(width=width)\n\n    fig.update_layout(\n        yaxis=dict(title=f\"{metric.capitalize()} {ENRICH_UNITS[metric]}\"),\n        showlegend=False,\n    )\n\n    return fig\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>For a more detailed changelog see CHANGELOG on GitHub</p>"},{"location":"changelog/#140","title":"1.4.0","text":""},{"location":"changelog/#140-2024-05-25","title":"1.4.0 (2024-05-25)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Zones and summary plots (#23) (7be77d0)</li> </ul>"},{"location":"changelog/#132","title":"1.3.2","text":""},{"location":"changelog/#132-2024-04-09","title":"1.3.2 (2024-04-09)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>profiles: Segment border crashed with partial data (#24) (5cf727f)</li> </ul>"},{"location":"changelog/#131","title":"1.3.1","text":""},{"location":"changelog/#131-2024-03-02","title":"1.3.1 (2024-03-02)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>visualization: Segment borders in profile plots are now drawn at the correct points (f5b71b9)</li> </ul>"},{"location":"changelog/#130","title":"1.3.0","text":""},{"location":"changelog/#130-2024-03-02","title":"1.3.0 (2024-03-02)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>visualization: Profile plots can display borders between segments/laps in track (2c18cd8)</li> <li>Track: plot method can be constrained to a subset of segments (#19) (56adca4)</li> <li>FITTrack: Save laps as segments and deal with missing elevation data (9beb65a)</li> </ul>"},{"location":"changelog/#120","title":"1.2.0","text":""},{"location":"changelog/#120-2024-01-28","title":"1.2.0 (2024-01-28)","text":""},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>get_closest_point: n_segment type hint and docstring reflects that full track can be used (453d0dd)</li> <li>cli tools are available via extra cli (#17) (712e59c)</li> </ul>"},{"location":"changelog/#112","title":"1.1.2","text":""},{"location":"changelog/#112-2024-01-14","title":"1.1.2 (2024-01-14)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Convert model dataclasses to pydantic models  (#16) (488600b)</li> <li>enhance-elevation cli (#15) (9318d93)</li> <li>visualize: Adding function for plotting data of multiple tracks (9b96054)</li> </ul>"},{"location":"changelog/#100","title":"1.0.0","text":""},{"location":"changelog/#100-2023-12-04","title":"1.0.0 (2023-12-04)","text":"<p>Release of first non-development version of the package on PyPi \ud83c\udf89</p> <p></p> <p>Full Changelog: https://github.com/kschweiger/track_analyzer/compare/0.5.3...1.0.0</p>"},{"location":"changelog/#051","title":"0.5.1","text":""},{"location":"changelog/#051-2023-12-03","title":"0.5.1 (2023-12-03)","text":""},{"location":"changelog/#050-2023-12-03","title":"0.5.0 (2023-12-03)","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Interpolation includes extentions heartrate, cadence, power (#13) (e777fa1)</li> <li>visualize.map: Adding map_style and line_width for map plot functions (0beaec2)</li> <li>Track: Adding split method (#11) (3ac4a42)</li> <li>Track: Added plot method (#9) (d71b888)</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>plot_segments_on_map: Plot now works with tracks w/o time (4789ddb)</li> <li>Track DataFrame with multiple segments was missing datapoints (975f1f9)</li> </ul>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>Renamed package to geo-track-analyzer (13779ef)</li> </ul>"},{"location":"cli/","title":"Command line interface","text":"<p>Not all dependencies for the command line interface utilities are not installed by default. Please use the <code>cli</code> extra during installation.</p>"},{"location":"cli/#enhance-elevation","title":"enhance-elevation","text":"<p>Enhance elevation data in a gpx file FILENAME using the Enahncer APIs provided in this package. Additional keyword-arguments for the Enhancers can be passed as key-value-pairs with = sizes. E.g. dataset=eudem25m for the OpenTopoElevationEnhancer.</p> <p>Usage:</p> <pre><code>enhance-elevation [OPTIONS] FILENAME [RAW_ENHANCER_INIT_ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --enhancer [OpenTopoElevation|OpenElevation]\n                                  Specify the enhancer type to be used to make\n                                  the requests.  [required]\n  --url TEXT                      URL of the API. Should be the full url\n                                  including port if necessary. Example:\n                                  http://localhost:8080/  [required]\n  --postfix TEXT                  String that will be appended to the output\n                                  file.  [default: enhanced_elevation]\n  -v, --verbose                   Set the verbosity level of the script.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#extract-fit-track","title":"extract-fit-track","text":"<p>Extract the track information for FILENAME file in fit format and save to regular gpx file</p> <p>Usage:</p> <pre><code>extract-fit-track [OPTIONS] FILENAME\n</code></pre> <p>Options:</p> <pre><code>  --name TEXT   Optinally set the Name property in the output file\n  --email TEXT  Optinally set the eMail property in the output file\n  --help        Show this message and exit.\n</code></pre>"},{"location":"comparison/","title":"Track comparison","text":"Warning <p>The features described in this section are not considered final and are subject to change. This may include breaking changes in minor releases!</p>"},{"location":"comparison/#finding-sub-segments-in-tracks","title":"Finding sub-segments in tracks","text":"<p>A segments in a <code>Track</code> can be compared to another segment via the  <code>Track.find_overlap_with_segment</code> method. The idea for this method is, that segment in the Track is the base against which the passed Segment is checked. This can be used to implemented features similar to Segments in Strava. On a match, overlapping segment from the orignal track is returned. Additionally the overlap ratio and the direction is included (<code>False</code> means both segments are running in the same direction).</p> Example <p>Image the following usecase: You have a longer track that includes serveral ascents and descents over a longer tour. You are interested how you performed on a particular ascent. Create a track with the ascent (only latitude/longitude coordinates required). Using the  <code>Track.find_overlap_with_segment</code> method on the <code>Track</code> of you tour and and track of the ascent you can extract segment corresponding to the ascent from the overall tour.</p> <p>The maching algorithm can be fine-tuned with the arguements of the functions:</p> <ul> <li><code>width</code>: The matching works by filling the points of the segments into 2D bins with a specific width in latitude and longitude direction. Overlap is determind by checking if points if both segments end up in the same bin.Smaller values of the  <code>width</code> parameter correspond to a stricter matching requirements.</li> <li><code>overlap_threshold</code>: Minimum overlap ratio required to return a match.</li> <li><code>max_queue_normalize</code>:  This parameter determines how many points needs to fall outside a bin before it can be counted as being visited an additional time in a track. Depends on the <code>width</code> setting. Larger values then to be saver but loops may be lost.</li> <li><code>merge_subsegments</code>: Maximum distance between matching sub-segments allowed before the sub-segments are not merged anymore. Depends on the <code>width</code> setting. The larger the values the larger gaps in matching are allowed. Drawback of large values are the possibility to merge segments that connected via some other segment.</li> </ul>"},{"location":"enhancer/","title":"Elevation enhancement","text":"<p>Updating or adding elevation data to a <code>Track</code> can be accomplished by using the classes implementing the <code>ElevationEnhancer</code> API.  This might be desirable for various reasons like:</p> <ul> <li>No elevation data was recorded</li> <li>The recorded elevation is data is inaccurate</li> <li>Elevation data should be synced between different Tracks</li> </ul> <p>Currently two interfaces for web-based REST API's are supported:</p> <ul> <li><code>OpenTopoElevationEnhancer</code>: Interface for OpenTopoData API (https://opentopodata.org)</li> <li><code>OpenElevationEnhancer</code>: Interface for  OpenElevation API (https://open-elevation.com)</li> </ul> <p>Depending on the API that should be used, settings are defined when initializing the object. See the specific documentation of the relevant objects and API's. When using the public (free) API's set as default in the objects, rate or similar restrictions may apply.</p> <p>A enhancer can be used like this:</p> <pre><code>enhancer = ElevationEnhancer()\n\nmy_track = GPXFileTrack(gpx_file=\"...\")\n\nenhancer.enhance_track(track=my_track.track, inplace=True)\n</code></pre> <p>See examples/enhance_elevation.py for a more detailed example.</p> <p>The author of this package recommends using a self hosted OpenTopoData API via a docker containers with a open source EU-DEM dataset for europe.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#installation","title":"Installation","text":"<p>To use Geo-Track-Analyzer, first install it using pip:</p> <pre><code>pip install geo-track-analyzer\n</code></pre> <p>Installing the package with cli extra, I.e. using <code>pip install geo-track-analyzer[cli]</code>, add utility tools. See the Command line interfaces page for details.</p>"},{"location":"usage/#analyze-geospacial-tracks","title":"Analyze geospacial tracks","text":"<p>The focus of this package lies on analyzing and visualizing tracks of cycling or similar activities. Depending on the usecase settings like <code>stopped_speed_threshold</code> or <code>max_speed_percentile</code> may not be appropriate.</p>"},{"location":"usage/#initialize-a-track","title":"Initialize a track","text":"<p>Tracks my be initialized from <code>.gpx</code> and <code>.fit</code> files using the <code>GPXFileTrack</code> and <code>FITTrack</code> object, respectively.</p> <p>Furhtermore the Track can be initialized programmatically from python objects inside your code using</p> <pre><code>    PyTrack(\n        points: list[tuple[float, float]] = ...,\n        elevations: None | list[float] = ...,\n        times: None | list[datetime] = ...,\n        heartrate: None | list[int] = None,\n        cadence: None | list[int] = None,\n        power: None | list[int] = None,\n    )\n</code></pre>"},{"location":"usage/#zones","title":"Zones","text":"<p>When intiliazing a track, zones for <code>heartrate</code>, <code>power</code>, and <code>cadence</code> can be set and are used for further analysis of a track. For this defined the zones via the <code>Zones</code> object:</p> <pre><code>Zones(\n    intervals=[\n        ZoneInterval(start=None, end=135),\n        ZoneInterval(start=135, end=146),\n        ZoneInterval(start=146, end=155),\n        ZoneInterval(start=155, end=165),\n        ZoneInterval(start=165, end=169),\n        ZoneInterval(start=169, end=174),\n        ZoneInterval(start=174, end=None),\n    ]\n)\n</code></pre> <p>Each <code>ZoneInterval</code> can also be defined with a <code>name</code> and a <code>color</code> attribute for further customization. For the interval definition, it is enforced</p> <ul> <li>that the first (last) interval starts (ends) with a <code>None</code> value and</li> <li>that consecutive intervals end/start with the same value.</li> </ul>"},{"location":"usage/#extracting-track-data","title":"Extracting track data","text":"<p>The data of the track can be extracted into a pandas DataFrame object with the columns:</p> <ul> <li>latitude: Track point latitude value</li> <li>longitude: Track point longitude value</li> <li>elevation: Track point elevation value</li> <li>speed: Speed in m/s calculated relative to previous point. Requires time to be present in track.</li> <li>distance: Distance in m relative to previous point</li> <li>heartrate: Heartrate in bpm (if present in input)</li> <li>cadence: Cadence in rmp(if present in input)</li> <li>power: Power in W (if present in input)</li> <li>time: Time in seconds relative to previous point. Time must be present in track.</li> <li>cum_time: Cummulated time of the track/segment in seconds. Requires time to be present in track.</li> <li>cum_time_moving: Cummulated moving time of the track/segment in seconds. Requires time to be present in track.</li> <li>cum_distance: Cummulated distance in track/segement in meters.</li> <li>cum_distance_moving: Cummulated moving distance in track/segement in meters.</li> <li>cum_distance_stopped: Cummulated stopped distance in track/segement in meters.</li> <li>moving: Bool flag specifing if the <code>stopped_speed_threshold</code> was exceeded for the point.</li> </ul> <p>Because some values are relative to previous points, the first point in the segment is not represented in this dataframe.</p> <p>Furthermore an summary of the segments and tracks can be generated in the form of a <code>SegmentOverview</code> containing:</p> <ul> <li>Time in seconds (moving and totoal)</li> <li>Distance in meters and km (moving and totoal)</li> <li>Maximum and average velocity in m/s and km/h</li> <li>Maximum and minimum elevation in meters</li> <li>Uphill and downhill elevation in meters</li> </ul>"},{"location":"usage/#visualizing-the-track","title":"Visualizing the track","text":"<p>Visualizations of a track can be generated via the <code>Track.plot</code> method via the <code>kind</code> parameter. Additionally the track data can be extracted with the <code>Track.get_track_data</code> or <code>Track.get_segment_data</code> methods and using the functions described in the Profiles and Maps and Summaries.</p>"},{"location":"vis_profiles_and_maps/","title":"Track visualization - Profiles and Maps","text":"<p>All visualizations are implemented using the Plotly Graphing Library. All methods and functions return a Figure objects to enable additonal customization of the plot outside of the package e.g. using the <code>update_layout</code> method.</p>"},{"location":"vis_profiles_and_maps/#elevations-profiles","title":"Elevations profiles","text":"<p>Multiple visualizations of the elevation profile of you tracks can be generated using the <code>Track.plot</code> method.</p>"},{"location":"vis_profiles_and_maps/#profile-with-and-without-additional-data","title":"Profile with and without additional data","text":"<p>Using <code>kind=\"profile\"</code> in <code>Track.plot</code> will generate a figure with the distance on the x-axis and the elevation on the y-axis. Internally this will call the <code>plot_track_2d</code> function. See the api documentation for all options that can be passed.</p> <p>Passing one of the boolean flags <code>include_velocity</code>, <code>include_heartrate</code>, <code>include_cadence</code>, or <code>include_power</code> will additonally plot the velocity, heartrate, cadence, or power on a secondary y-axis, respectively if available. Heart Rate and Power are visualized as line plot</p> <p>while the cadence is visualized with markers</p> <p>If <code>Zones</code> are set for Heart Rate, Cadence, or Power, these zones can be visualized in the profile plot by passing <code>split_by_zone</code> to the in <code>Track.plot</code> method or <code>plot_track_2d</code> function.</p>"},{"location":"vis_profiles_and_maps/#profile-with-slopes","title":"Profile with slopes","text":"<p>Using <code>kind=\"profile-slope\"</code> in <code>Track.plot</code> will also generate a profile like before but additonally the slope between each point will be calcuated and viszalized in the plot by coloring the line and filling. Depending on the density of the points by using the <code>reduce_pp_intervals</code> argument. Internally this will call the <code>plot_track_with_slope</code> function. See the api documentation for all options that can be passed.</p> <p>Color scale and min/max slope can be configured using the <code>slope_gradient_color</code>, <code>min_slope</code>, and <code>max_slope</code> arguments as documented in <code>plot_track_with_slope</code>.</p>"},{"location":"vis_profiles_and_maps/#displaying-segmentslaps-in-profile-plots","title":"Displaying segments/laps in profile plots","text":"<p>Plots of kinds <code>profile-slope</code> and <code>profile</code> can show the segments (or laps) in a track by passing the <code>show_segment_borders</code> argument. This add a vertical line at the distance corresponding to the first point in the segment. The color of the lien can be modified with by passing <code>color_segment_border</code> with a valid color string for plotly.</p>"},{"location":"vis_profiles_and_maps/#map-visualizations","title":"Map Visualizations","text":"<p>Multiple visualizations of the path of the track on a map can be generated using the <code>Track.plot</code> method. As default to Open Streetmap style is used for map. By passing <code>map_style</code> with a valid Plotly Mapboxstyle value this can be changed.</p>"},{"location":"vis_profiles_and_maps/#line-on-map","title":"Line on map","text":"<p>Using <code>kind=\"map-line\"</code> in <code>Track.plot</code> will generate a figure with the track path on a map. Internally this will call the <code>plot_track_line_on_map</code> function. See the api documentation for all options that can be passed.</p>"},{"location":"vis_profiles_and_maps/#individual-segments-lines-with-summary-data-on-map","title":"Individual segments lines with summary data on map","text":"<p>Using <code>kind=\"map-segments\"</code> in <code>Track.plot</code> will generate a figure with the track path on a map. This plot can only be generated if the Track contains multiple segments. Otherwise an <code>VisualizationSetupError</code> will be raised. If two or more segments are present, the path will be split and colored into different segments and min/max/average of elevation, speed, heartrate, cadence, and power will be shown when hovering over the segment. Internally this will call the <code>plot_segments_on_map</code> function. See the api documentation for all options that can be passed.</p>"},{"location":"vis_profiles_and_maps/#line-on-map-with-additonal-data","title":"Line on map with additonal data","text":"<p>Using <code>kind=\"map-line-enhanced\"</code> in <code>Track.plot</code> will generate a figure with the track path on a map. Additionally elevation, speed, heartrate, cadence, or power will be added via the color of the path. Set by passing the <code>enrich_with_column</code> argument. Internally this will call the <code>plot_track_enriched_on_map</code> function. See the api documentation for all options that can be passed.</p> <p>Unlike with the previous line plots, the individual track points are shown on the map and not the line connection consecutive points. For dense tracks this is no problem on normal zoom levels showing the whole track. But gaps may appear for sparse tracks as show below.</p> <p>Use the inerpolate feature <code>Track.interpolate_points_in_segment</code> to increase the density with a following result:</p> <p>The line can also be colored based on the <code>Zones</code> set in the track for Heart Rate, Cadence, and Power by passing <code>color_by_zone=True</code> in the argument of <code>Track.plot</code> or <code>plot_track_enriched_on_map</code>.</p>"},{"location":"vis_summaries/","title":"Track visualization - Summaries","text":""},{"location":"vis_summaries/#segment-summaries","title":"Segment summaries","text":"<p>If multiple segments are included in a track, summaries per segments can be generated. Passing <code>kind=\"segment_summary\"</code> in <code>Track.plot</code> will benerate bar charts with a <code>aggregate</code> value that must be passed as additional keyword agrument. Internally this will call the  <code>plot_segment_summary</code> function. See the api documentation for all options that can be passed.</p> <p>Currently the folloing aggregation metrics are supported:</p> <ul> <li>Passing <code>aggregate=\"avg_speed\"</code> o generate a plot with the average velocity in a segment:</li> </ul> <ul> <li>Passing <code>aggregate=\"max_speed\"</code> o generate a plot with the maximum velocity in segment</li> </ul> <p>Passing <code>aggregate=\"total_distance\"</code> o generate a plot with the total distance covered in segment</p> <ul> <li>Passing <code>aggregate=\"total_time\"</code> o generate a plot with the total time spend in segment</li> </ul>"},{"location":"vis_summaries/#box-plots","title":"Box plots","text":"<p>Box plots are a way to visualize how data is distributed in a given sample. If multiple segments are included in a track, such box plots can be generated by passing <code>kind=\"segment_box\"</code> in <code>Track.plot</code> and one of the metrics <code>\"heartrate\"</code>, <code>\"power\"</code>, <code>\"cadence\"</code>, <code>\"speed\"</code>, <code>\"elevation\"</code> with the <code>metric</code> keyword. Internally this will call the  <code>plot_segment_box_summary</code> function. See the api documentation for all options that can be passed.</p>"},{"location":"vis_summaries/#zone-summaries","title":"Zone summaries","text":"<p>When defining <code>Zones</code> for <code>heartrate</code>, <code>cadence</code>, or <code>power</code>, visualizations summarizing some metric per zone are provided.</p>"},{"location":"vis_summaries/#zones-for-the-whole-track","title":"Zones for the whole track","text":"<p>Using <code>kind=\"zone_summary\"</code> in <code>Track.plot</code> will generate a figure bar representing an <code>aggregate</code> value for a <code>metric=heartrate|cadence|power</code>.  Internally this will call the  <code>plot_track_zones</code> function. See the api documentation for all options that can be passed.</p> <p>Currently the following aggregation metrics are supported:</p> <ul> <li>Passing <code>aggregate=\"time\"</code> to generate a plot with the total time spent in a zone of the passed <code>metric</code>:</li> </ul> <ul> <li>Passing <code>aggregate=\"distance\"</code> in to generate a plot with the total distance covered in a zone of the passed <code>metric</code>:</li> </ul> <ul> <li>Passing <code>aggregate=\"speed\"</code> to generate a plot with the average velocity covered in a zone of the passed <code>metric</code>:</li> </ul>"},{"location":"vis_summaries/#zones-per-segement","title":"Zones per segement","text":"<p>Additionally the some aggregation metrics can be split per segment in a track by passing <code>kind=\"segment_zone_summary\"</code>.  Internally this will call the  <code>plot_segment_zones</code> function. See the api documentation for all options that can be passed.</p> Errors will be raised <p>An <code>VisualizationSetupError</code> is passed if <code>aggregate</code> and <code>metric</code> keyword-argument pairs are not passed to the <code>plot</code> method for kinds <code>\"zone_summary\"</code> and <code>\"segment_zone_summary\"</code></p>"}]}